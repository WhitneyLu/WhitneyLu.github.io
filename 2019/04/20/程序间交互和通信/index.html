<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="google-site-verification" content="eaUMXvNaTlS5XY6VQbEb2OQ9XI-jGDm0VQvmNHMz5qI">
<meta name="baidu-site-verification" content="8GfnZRBeT5">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="https://fonts.cat.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="程序间交互和通信-系统级I/O、网络编程、并发编程">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="程序间交互和通信">
<meta property="og:url" content="https://whitneylu.github.io/2019/04/20/程序间交互和通信/index.html">
<meta property="og:site_name" content="Whitney&#39;s coding note">
<meta property="og:description" content="程序间交互和通信-系统级I/O、网络编程、并发编程">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://whitneylu.github.io/image/mode参数访问权限位.png">
<meta property="og:image" content="https://whitneylu.github.io/image/stat数据结构的成员.png">
<meta property="og:image" content="https://whitneylu.github.io/image/两个不同的描述符打开不同的文件.jpg">
<meta property="og:image" content="https://whitneylu.github.io/image/文件共享.jpg">
<meta property="og:image" content="https://whitneylu.github.io/image/子进程继承父进程的打开文件.jpg">
<meta property="og:image" content="https://whitneylu.github.io/image/主机AB之间传送数据的8个步骤.jpg">
<meta property="og:image" content="https://whitneylu.github.io/image/信号量调度共享资源.png">
<meta property="og:updated_time" content="2019-06-03T17:28:24.161Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序间交互和通信">
<meta name="twitter:description" content="程序间交互和通信-系统级I/O、网络编程、并发编程">
<meta name="twitter:image" content="https://whitneylu.github.io/image/mode参数访问权限位.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://whitneylu.github.io/2019/04/20/程序间交互和通信/">





  <title>程序间交互和通信 | Whitney's coding note</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Whitney's coding note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Study as if you were going to live forever.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://whitneylu.github.io/2019/04/20/程序间交互和通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WhitneyLu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/nessa.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whitney's coding note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序间交互和通信</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-20T00:00:00+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/程序间交互和通信/" itemprop="url" rel="index">
                    <span itemprop="name">程序间交互和通信</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  23
                </span>
              
            </div>
          

          
              <div class="post-description">
                  程序间交互和通信-系统级I/O、网络编程、并发编程
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="程序间交互和通信"><a href="#程序间交互和通信" class="headerlink" title="程序间交互和通信"></a>程序间交互和通信</h1><h2 id="系统级I-O"><a href="#系统级I-O" class="headerlink" title="系统级I/O"></a>系统级I/O</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ol>
<li>普通文件：文本文件和二进制文件</li>
<li>目录包含一组链接的文件，每个链接都将文件映射到另一个文件。每个目录至少包含两个条目：’.’表示目录本身的链接和’..’表示父目录的链接</li>
<li><strong>套接字</strong>是用来与另一个进程的进行跨网通信的文件</li>
<li>其他文件类型还包括命名通道、符号链接以及字符和块设备</li>
</ol>
<h4 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h4><ol>
<li>open函数打开文件或者创建一个新文件，open将filename转换为一个文件描述符，并且返回文件描述符<br><code>fd=Open(&quot;foo.tst&quot;,O_RDONLY,0);</code>以只读的方式打开一个已存在的文件</li>
<li>flag参数可以是一个或多个位的掩码的或，为写提供一些额外的指示</li>
<li>O_CREAT表示如果文件不存在，就创建它的一个截断的空文件；O_TRUNC表示如果文件已经存在，就截断它；O_APPEND表示每次写操作前，设置文件位置到文件结尾处<br><code>fd=Open(&quot;foo.tst&quot;,O_WRONLY|O_APPEND,0)</code></li>
<li>mode参数设置新文件的访问权限位<br><img src="/image/mode参数访问权限位.png" alt></li>
<li>进程使用close关闭文件</li>
</ol>
<h4 id="读和写程序"><a href="#读和写程序" class="headerlink" title="读和写程序"></a>读和写程序</h4><ol>
<li><p>程序通过read和write函数执行输入和输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd,void *buf,size_t n);</span><br><span class="line">//read函数从描述符为fd的当前文件复制最多n个字节到内存位置buf</span><br><span class="line">//若成功则返回读的字节数，若EOF返回0，若失败返回-1</span><br><span class="line"></span><br><span class="line">ssize_t write(int fd,const void *buf,size_t n);</span><br><span class="line">//write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置</span><br><span class="line">//成功返回写的字节数，失败返回-1</span><br><span class="line"></span><br><span class="line">//read和write传送的字节比应用程序要求的少，不足值不代表错误</span><br><span class="line">//如果打开的文件应用于网络套接字，内存缓冲约束和较长的网络延迟会引起read和write返回不足值</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过调用lseek函数能够修改当前文件的位置</p>
</li>
<li>用RIO包读写（Robust I/O）</li>
</ol>
<ul>
<li>无缓冲的输入输出函数，直接在内存和文件之间读写文件</li>
<li>带缓冲的输入输出函数，缓存在应用级的缓冲区内</li>
</ul>
<ol start="4">
<li>无缓冲的输入输出函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;&quot;csapp.h&quot;&gt;</span><br><span class="line">ssize_t rio_readn(int fd,void *usrbuf,size_t n);</span><br><span class="line">//从描述符为fd的当前文件复制最多n个字节到内存位置usrbuf</span><br><span class="line">ssize_t rio_writen(int fd,void *usrbuf,size_t n);</span><br><span class="line">//从内存位置usrbuf复制至多n个字节到描述符fd</span><br><span class="line">//只有遇到EOF时才会返回不足值，对同一个描述符可以任意交错调用rio_readn和rio_writen的代码</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>5.带缓冲的输入输出函数，调用包装函数，从内部缓冲区复制一个文本行，当缓冲区变空时，自动调用read填满<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;&quot;csapp.h&quot;&gt;</span><br><span class="line"></span><br><span class="line">void rio_readinitb(rio_t *rp,int fd);</span><br><span class="line">ssize_t rio_readlineb(rio_t fd,void *usrbuf,size_t maxlen);</span><br><span class="line">//每打开一个描述符，都会调用一次rio_readinitb函数，将描述符fd和地址rp处的读缓冲区联系起来</span><br><span class="line">//rio_readinitb函数从文件rp中读出下一个文本行（包括结尾的换行符），将它复制到内存为止，usrbuf用NULL结束这个文本行</span><br><span class="line">//rio_readinitb函数最多读maxlen-1个字节，余下的一个字节留给NULL，超过的字符被截断</span><br><span class="line">ssize_t rio_readnb(rio_t fd,void *usrbuf,size_t n);</span><br><span class="line">//rio_readnb函数从文件rp中最多读n个字节到内存位置usrbuf</span><br><span class="line">//对同一个描述符，可以任意交叉调用rio_readinitb和rio_readnb</span><br></pre></td></tr></table></figure></p>
<h3 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h3><ol>
<li>程序调用stat和fstat函数，检索到关于文件的信息（文件元数据）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">int stat(const char *filename,struct stat *buf);</span><br><span class="line">//以文件名作为输入，填写stat数据结构中的各个成员，Web服务器需要stat数据结构中的st_mode和st_size成员</span><br><span class="line">int fstat(int fd,struct stat *buf);</span><br><span class="line">//以文件描述符作为输入</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/image/stat数据结构的成员.png" alt></p>
<h3 id="读取目录内容"><a href="#读取目录内容" class="headerlink" title="读取目录内容"></a>读取目录内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//程序用readdir系列函数来读取目录的内容</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">DIR *opendir(const char *name);</span><br><span class="line">//以路径名为参数，返回指向目录流的指针（目录项列表），出错则返回NULL</span><br><span class="line"></span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">struct dirent *readdir(DIR *dirp);</span><br><span class="line">//每次对readdir的调用的返回都指向流dirp中下一个目录项的指针，如果失败返回NULL并设置errno</span><br><span class="line"></span><br><span class="line">//每个目录的结构</span><br><span class="line">struct dirent&#123;</span><br><span class="line">	ino_t d_ino;//文件位置</span><br><span class="line">	char d_name[256];//文件名</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">int closedir(DIR *dirp);</span><br><span class="line">//关闭流并释放所有资源</span><br></pre></td></tr></table></figure>
<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><ol>
<li>内核用三个相关的数据结构表示打开的文件：</li>
</ol>
<ul>
<li>描述符表：表项由进程打开的文件描述符索引的，，每个打开的描述符表项指向文件表中的一个表项</li>
<li>文件表：所有进程共享表示打开文件集合的文件表，每个文件表项组成包括当前文件位置、引用计数、以及指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数，内核不会删除这个文件表表项，直到引用计数为0</li>
<li>v-node表：所有进程共享，每个表项包含stat结构的大多数信息</li>
</ul>
<ol start="2">
<li>多个描述符通过不同的文件表表项引用同一个文件，如以同一个filename调用open两次<br><img src="/image/两个不同的描述符打开不同的文件.jpg" alt><br>文件共享<br><img src="/image/文件共享.jpg" alt><br>子进程继承父进程的打开文件<br><img src="/image/子进程继承父进程的打开文件.jpg" alt></li>
</ol>
<h4 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h4><ol>
<li>Linux shell提供了I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来<br><code>ls &gt;foo.txt #将标准输出重定向到磁盘文件</code></li>
<li>I/O重定向通过dup2工作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup2(int oldfd,int newfd);</span><br><span class="line">//复制描述符表表项oldfd到描述符表表项newfd，覆盖newfd表项以前的内容，如果newfd已经打开了，则在oldfd复制之前关闭newfd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ol>
<li>库libc提供了fopen、fclose、fread、fwrite、fgets、fputs、scanf和printf</li>
<li>将打开的文件模型化为一个流，类型为FILE的刘是对文件描述符和流缓冲区的抽象</li>
</ol>
<h3 id="选择合适的I-O"><a href="#选择合适的I-O" class="headerlink" title="选择合适的I/O"></a>选择合适的I/O</h3><ol>
<li>首选标准I/O</li>
<li>不要使用scanf和rio_readlineb来读二进制文件</li>
<li>对网络套接字的I/O使用RIO函数</li>
<li>标准I/O是全双工的，程序能够在同一个流上执行输入和输出</li>
<li><strong>限制一：</strong>如果中间没有插入fflush、fseek、fsetpos和rewind的调用，<strong>输入函数不能跟在输出函数之后</strong>，fflush清空与流相关的缓冲区，后三个函数使用lseek函数重置当前文件位置。在每个输入操作前刷新缓冲区</li>
<li><strong>限制二：</strong>如果中间没有插入fseek、fsetpos和rewind函数的调用，输出函数不能跟随在输入函数之后。对网络套接字使用lseek是非法的，对同一个打开的套接字打开两个流，一个用来写一个用来读</li>
<li>在网络套接字上不适用标准I/O，要使用RIO函数</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><ol>
<li>客户端和服务器运行在不同的主机上，通过计算机网络的硬件和软件资源来通信</li>
<li>网络是一种I/O设备，是数据源也是数据接收方，网络的物理接口，从网络上接收到的数据从适配器经过I/O和内存总线复制到内存，通过DMA传送，类似的数据也能从内存复制到网络</li>
<li><strong>物理网络最底层LAN</strong>，最流行的局域网技术是<strong>以太网</strong>，集线器不加分辨的将从一个口收到的东西复制到其他每个口，每台主机都能看到每个位，每个以太网适配器都要有唯一的48位地址，存储在适配器的非易失性存储器上</li>
<li>主机可以发送帧到这个网段内的其他任何主机，每个帧都包含固定数量的头部，用来标识此帧的源和目的，此后紧跟的是数据位的有效载荷，每个主机适配器都可以看到这个帧，但是只有目的主机可以实际读取他</li>
<li>使用电缆和网桥可以将多个以太网段连接成较大的局域网，称为<strong>桥接局域网</strong>，网桥有选择地将帧从一个端口复制到另一个端口</li>
<li>多个不兼容的局域网可以通过路由器的特殊计算连接起来，组成互联网络</li>
<li>路由器连接到高速点到点电话连接，称为<strong>WAN广域网</strong></li>
<li>用运行在每台主机和路由器上的<strong>软件协议</strong>，消除不同网络之间的差异，协议的两种基本能力：</li>
</ol>
<ul>
<li><strong>命名机制</strong>，用一致的主机地址格式消除不兼容的局域网技术带来的差异，每台主机至少被分配一个互联网络地址，唯一的标识主机</li>
<li><strong>传送机制</strong>，互联网协议定义一种将数据位捆扎成<strong>包</strong>（不连续的片）的统一方式消除差异。</li>
</ul>
<ol start="13">
<li>包由包头和有效载荷组成，包头包含源主机和目的主机的地址，有效载荷包括从源主机发出的数据位</li>
<li>主机A传送数据到主机B的8个步骤如图所示<br><img src="/image/主机AB之间传送数据的8个步骤.jpg" alt></li>
</ol>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ol>
<li>IP地址就是32位无符号整数（IPv4）</li>
<li><p>IP地址结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct in_addr&#123;</span><br><span class="line">	uint32_t s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP/IP为任意整数数据项定义了统一的<strong>网络字节顺序</strong>（大端字节顺序），Unix使用函数在网络和主机字节顺序间实时转换</p>
</li>
<li><p>IP地址通常是点分十进制表示的，128.2.194.242就是地址0x8002c2f2。Linux系统中可以用一下命令来确定主机的点分十进制地址<code>hostname -i</code></p>
</li>
</ol>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ol>
<li>应用程序并发在以下几种情况是很有用的：访问慢速I/O设备、与人交互、通过推迟工作降低延迟、服务多个网络客户端、在多核机器上进行并行运算</li>
<li>三种基本构造并发程序的方法：<strong>进程、I/O多路复用、线程</strong></li>
</ol>
<h3 id="基于进程的并发编程"><a href="#基于进程的并发编程" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h3><ol>
<li>在父进程接受客户端的连接请求，然后创建一个新的子进程来为每个新客户端提供服务</li>
<li>服务器监听一个监听描述符上的连接请求，然后假设服务器接受了客户端1的连接请求，并返回一个已连接描述符。在接受连接请求后，服务器派生子进程</li>
<li>这个子进程获得服务器描述表的完整副本，子进程关闭它的副本中的监听描述符3，父进程关闭已连接描述符4的副本，否则会引起内存泄露</li>
<li>包括SIGCHLD处理程序，回收僵死程序，当SIGCHLD处理程序执行时，SIGCHLD信号的阻塞的</li>
<li>父进程必须关闭它们各自的connfd副本</li>
<li>套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭了，到客户端的连接才会终止</li>
<li>进程并发的劣势：</li>
</ol>
<ul>
<li>父进程和子进程共享状态信息，进程有一个清晰的模型，共享文件表，但是不共享用户地址空间</li>
<li>独立的地址空间使得进程共享状态信息变得困难，必须使用显式的IPC（进程间通信）机制进行共享信息</li>
<li>进程控制和IPC开销很高，运行很慢，套接字接口是IPC的一种重要形式，允许不同的主机上的进程交换任意的字节流，包括管道、先进先出、系统V共享内存以及系统V信号量</li>
</ul>
<h3 id="基于I-O多路复用的并发编程"><a href="#基于I-O多路复用的并发编程" class="headerlink" title="基于I/O多路复用的并发编程"></a>基于I/O多路复用的并发编程</h3><ol>
<li>服务器响应两个相互独立的I/O时间：1）网络客户端发起连接请求；2）用户在键盘键入命令行</li>
<li><p>使用select函数，要求挂起进程，只有在一个或多个I/O时间发生后，才将控制返回给程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//等待一组描述符准备好读</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">int select(int n, fd_set *fdset, NULL, NULL, NULL);</span><br><span class="line"> </span><br><span class="line">FD_ZERO(fd_set *fdset);//创建于一个空的读集合</span><br><span class="line">FD_CLR(int fd, fd_set *fdset);//</span><br><span class="line">FD_SET(int fd, fd_set *fdset);//定义读集合</span><br><span class="line">FD_ISSET(int fd, fd_set *fdset);//确定哪个描述符准备好读了</span><br><span class="line">//fd_set集合是描述符集合</span><br><span class="line">/*允许对描述符做三件事，分配它们，将此种类型的变量赋值给另一个变量，用FD_ZERO、FD_CLR、FD_SET和FD_ISSET宏来修改它们*/</span><br><span class="line">/*select函数会一直阻塞，直到读集合中至少有一个描述符准备好可以读。从该描述符读取一个字节不会阻塞*/</span><br><span class="line">/*函数修改参数fdset，返回值指明准备好集合的技术，每次调用select函数都会更新读集合*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦连接到某个客户端，就会连续回送输入行，直到客户端关闭连接中的一端</p>
</li>
</ol>
<h4 id="I-O复用的优势和劣势"><a href="#I-O复用的优势和劣势" class="headerlink" title="I/O复用的优势和劣势"></a>I/O复用的优势和劣势</h4><ol>
<li>优点：有更多的对程序行为的控制；运行在单一进程的上下文中，每个逻辑控制流都能访问该进程的全部地址空间；共享进程容易，可以用熟悉的调试工具调试并发服务器</li>
<li>事件驱动的缺点：编码复杂，代码比基于进程的服务器多3被；并发<strong>粒度</strong>减小，复杂性上升；在故意只发送部分文本然后停止的恶意客户端攻击前很脆弱；不能充分利用多核处理器</li>
<li><strong>粒度</strong>是每个逻辑流每个事件片执行的指令数量</li>
</ol>
<h3 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h3><ol>
<li>线程是运行在进程上下文中的逻辑流，线程由内核自动调度</li>
<li>每个线程都有自己的线程上下文，包括线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码</li>
<li>所有运行在一个进程中的线程共享该进程的整个虚拟空间</li>
</ol>
<h4 id="线程执行模型"><a href="#线程执行模型" class="headerlink" title="线程执行模型"></a>线程执行模型</h4><ol>
<li>每个进程开始都是单一线程，这个线程称为<strong>主线程</strong></li>
<li>主线程创建一个<strong>对等线程</strong>，从这个时间点开始，两个进程并发地运行</li>
<li>主线程执行一个满系统调用，或者被系统的间隔计时器中断，控制会通过上下文切换传递到对等线程</li>
<li>线程的上下文比进程的上下文小很多，线程的上下文切换比进程的上下文切换快的多</li>
<li>主线程总是第一个运行的线程</li>
<li>和一个进程相关的进程组成一个对等线程池，独立于线程产生的线程</li>
<li>一个线程可以kill它的任何对等线程，或者等待它的任意对等线程终止</li>
<li>每个对等线程都能读写相同的<strong>共享数据</strong></li>
</ol>
<h4 id="Posix线程"><a href="#Posix线程" class="headerlink" title="Posix线程"></a>Posix线程</h4><ol>
<li>Posix线程是C程序中处理线程的一个<strong>标准接口</strong>，定义了约60个函数，允许程序创建、杀死和回收线程，与对等线程安全的共享数据，通知对等线程系统状态的变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">void *thread(void *vargp);</span><br><span class="line">/*线程的本地代码被封装在一个线程例程中，每个线程例程都以一个通用指针作为输入，并返回一个通用指针*/</span><br><span class="line">/*如果要传递多个参数给线程，将多个参数放在一个结构中，传递一个指向该结构的指针*/</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid;						/*tid存放对等线程的ID*/</span><br><span class="line">    Pthread_create(&amp;tid, NULL, thread. NULL);</span><br><span class="line">    /*创建一个新的对等线程，主线程和新创建的对等线程同时运行，并且tid包含新线程的ID*/</span><br><span class="line">    Pthread_join(tid, NULL);			/*主线程等待对等线程终止*/</span><br><span class="line">    exit(0);								/*终止运行在这个进程中的所有线程*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread(void *vargp)				/*定义对等线程*/</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello,world!\n&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><ol>
<li>线程通过调用pthread_create来创建其他线程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">typedef void *(func)(void *);</span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg);</span><br><span class="line">/*输入变量arg，在新线程上下文中运行线程例程f*，能用attr参数来改变新创建线程的默认属性，tid包含线程ID/</span><br><span class="line"></span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_t pthread_self(void);		/*新线程调用pthread_self函数来获得自己的线程ID*/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><ol>
<li>顶层的线程例程返回时，线程隐性终止</li>
<li>调用pthread_exit函数，线程会显式的终止，等待所有其他对等线程终止，再终止主线程和整个进程，返回值为thread_return</li>
<li>某个线程调用Linux的exit函数，函数终止该进程以及与该进程相关的线程</li>
<li>另一个对等线程通过当前进程ID作为参数调用pthread_cancel函数来终止当前线程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_exit(void *thread_return);</span><br><span class="line"></span><br><span class="line">void pthread_cancel(pthread_t tid);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//回收已终止线程的资源</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_join(pthread_t tid, void **thread_return);</span><br><span class="line">/*函数会阻塞，直到线程tid终止，将线程例程返回的通用void*指针赋值为thread_return指向的位置*/</span><br><span class="line">/*然后回收已终止线程占用的所有内存资源*/</span><br><span class="line">/*pthread_join只能等待一个指定的线程终止*/</span><br></pre></td></tr></table></figure>
<h4 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h4><ol>
<li>在任何一个时间点上线程是可结合的或者是分离的</li>
<li>可结合的线程能够被其他线程收回或杀死，在被其他线程回收前，它的内存资源不释放</li>
<li>分离的线程不能被其他线程回收或者杀死，内存资源在终止时被释放</li>
<li>默认情况下，线程被创建成可结合的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_detach(pthread_t tid);</span><br><span class="line">/*分离可结合线程tid*/</span><br><span class="line">/*web浏览器的连接请求都创建一个新的对等线程，不需要显式的等待每个线程的终止*/</span><br><span class="line">/*每个对等线程都应该在开始处理请求之前分离它自身，就能在终止后回收它的内存资源*/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h4><ol>
<li>pthread_once函数允许初始化线程例程相关的状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_once once_control=PITHREAD_ONCE_INIT;</span><br><span class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));</span><br><span class="line">/*once_control是一个全局变量或者静态变量，总是被初始化为PITHREAD_ONCE_INIT*/</span><br><span class="line">/*第一次用参数once_control调用pthread_once时，调用init_routine*/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="基于线程的并发服务器"><a href="#基于线程的并发服务器" class="headerlink" title="基于线程的并发服务器"></a>基于线程的并发服务器</h4><ol>
<li>主进程不断等待连接请求，创建一个对等线程处理该请求</li>
<li>将已连接描述符传递给对等线程，传递这个描述符的指针，但是这种对等线程的赋值语句和主线程的语句之间引入了<strong>竞争</strong>，将accept返回的每个已连接描述符分配到自己的动态分配内存块</li>
<li>为了避免内存泄露，必须分离每个线程，使得他终止时的每个内存资源能被收回</li>
<li>线性内存模型</li>
</ol>
<ul>
<li>一组并发线程运行在进程的上下文中，每个线程都有自己的上下文</li>
<li>每个线程和其他线程共享进程上下文的剩余部分，包括用户虚拟内存空间，是由只读文本、读写数据、堆以及所有共享库代码和数据区域组成的。线程也共享相同的打开文件合集</li>
</ul>
<ol start="5">
<li>将变量映射到内存</li>
</ol>
<ul>
<li><strong>全局变量：</strong>虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用</li>
<li><strong>本地自动变量：</strong>是定义在函数内部，但是没有static属性的变量，在运行时，每个线程的栈都包含它自己所有自动变量的实例</li>
<li><strong>本地静态变量：</strong>是定义在函数内部并且有static属性的变量，虚拟内存的读/写区域只包含每个静态变量的一个实例<br>6.共享变量，变量的一个实例被多个线程引用</li>
</ul>
<h3 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h3><ol>
<li>共享变量引入同步错误</li>
<li>两个对等线程在单处理器上同步运行，导致循环中的步骤错乱</li>
</ol>
<h4 id="进度图"><a href="#进度图" class="headerlink" title="进度图"></a>进度图</h4><ol>
<li><strong>进度图</strong>将指令模型化为一种状态到另一种状态的转换，转换被表示为有向线段</li>
<li>两条指令不能同时完成，不允许对角转换，不允许反向执行，不能向下或者向左</li>
<li>线程的临界区不允许和其他进程的临界区交替执行</li>
<li>保证每个线程在执行临界区时，有对共享内存变量的<strong>互斥</strong>访问</li>
<li>两个交界区形成的状态空间区域成为<strong>不安全区</strong></li>
<li>绕开不安全区域的轨迹线叫做<strong>安全轨迹线</strong></li>
</ol>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ol>
<li>信号量s是具有非负整数值的全局变量，只能由两种特殊的操作来处理P和V</li>
<li>P(s):如果s非0，s-1，如果s为零，挂起这个线程，直到s为非0</li>
<li>V(s):s+1，如果有操作阻塞在P等待s变成非0，V操作会重启线程中的一个，然后P将s-1</li>
<li><p>P和V保证正确初始化的信号量不会有一个负值，这个属性称为<strong>信号量不变性</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//POSIX标准定义了许多操作信号量的函数</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">int sem_init(sem_t *sem, 0, unsigned int value); /*将信号量sem初始化为value*/</span><br><span class="line">int sem_wait(sem_t *s); //执行P操作</span><br><span class="line">int sem_post(sem_t *s); //执行V操作</span><br><span class="line"></span><br><span class="line">//等价的P和V的包装函数</span><br><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">void P(sem_t *s);</span><br><span class="line">void V(sem_t *s);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用信号量来实现互斥</p>
</li>
</ol>
<ul>
<li>用P(s)和V(s)将临界区包围起来，使用这种<strong>二元信号量</strong>来保护共享变量的信号量</li>
<li>提供互斥为目的的二元信号量通常也称<strong>信号锁</strong>，P是<strong>互斥锁加锁</strong>，V是<strong>互斥锁解锁</strong></li>
<li>一个被用作一组可用资源计数的信号量被称为是计数信号量</li>
<li>使用s&lt;0的状态建立一个禁止区，保证了临界区的互斥访问</li>
</ul>
<h4 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h4><p><img src="/image/信号量调度共享资源.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typrdef struct&#123;</span><br><span class="line">	int *buf;</span><br><span class="line">	int n;</span><br><span class="line">	int front;		/*索引值，记录数组的第一项*/</span><br><span class="line">	int rear;			/*索引值，记录数组的最后一项*/</span><br><span class="line">	sem_t mutex;		/*提供互斥的缓冲区访问*/</span><br><span class="line">	sem_t slots;		/*记录空槽位数量*/</span><br><span class="line">	sem_t items;		/*记录可用项目的数量*/</span><br><span class="line">&#125;sbuf_t;</span><br><span class="line"></span><br><span class="line">/*sbuf_init函数为缓冲区分配内存，初始化所有变量*/</span><br><span class="line">void sbuf_init(sbuf_t *sp, int n)</span><br><span class="line">&#123;</span><br><span class="line">	sp-&gt;buf=Calloc(n,sizeof(int));</span><br><span class="line">	sp-&gt;n;</span><br><span class="line">	sp-&gt;front=sp-&gt;rear=0;</span><br><span class="line">	Sem_init(&amp;sp-&gt;mutex,0,1);</span><br><span class="line">	Sem_init(&amp;sp-&gt;slots,0,n);</span><br><span class="line">	Sem_init(&amp;sp-&gt;items,0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>读者-写者问题</strong>读者优先，如果不是使用权限赋给写，读操作不需要等待；写优先，在写者后面到达的读者必须等待</li>
</ol>
<h3 id="使用线程提高并行性"><a href="#使用线程提高并行性" class="headerlink" title="使用线程提高并行性"></a>使用线程提高并行性</h3><ol>
<li>将序列分配成t个不想交的区域，然后给t个不同的线程分配区域</li>
<li>为了避免多核之间全局变量同步和PV操作造成的大延迟，在每个线程中使用私有变量/局部变量计算局部和，这个私有变量不和其他线程共享，不需要互斥锁来保护更新，也不需要每次循环都同步全局变量</li>
<li>并行程序加速比：Sp=T1/Tp</li>
<li>相关测量量-效率：Ep=Sp/p=T1/pTp，具有高效率的程序比低效率的程序在有用的工作上花费更多的时间</li>
<li><strong>弱扩展</strong>：在增加处理器数量的同时，增加问题的规模</li>
</ol>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ol>
<li><strong>线程安全</strong>被多个并发线程反复强调，一直产生安全的结果，否则这个函数就是<strong>线程不安全</strong>的</li>
</ol>
<ul>
<li>第1类：不保护共享变量的函数</li>
<li>第2类：保持跨越多个调用的状态的函数：单线程中使用另一个函数设置种子，多线程中不再使用任何static数据，重写函数编程可重入函数</li>
<li>第3类：指向静态变量的指针的函数：重写函数或者使用加锁-复制技术，定义线程安全的包装函数，通过调用包装函数来避免线程不安全函数的调用</li>
<li>调用线程不安全的函数：第2类只能重写函数编程可重入函数，第1、3类同第3种使用带有互斥锁的包装函数</li>
</ul>
<ol start="2">
<li><strong>可重入函数</strong>，一个重要的线程安全的函数，在被多个线程共享时，不会引用任何共享数据，是线程安全函数的一部分</li>
</ol>
<ul>
<li>没有同步操作，比不可重入函数更高效一点</li>
<li>只有值传递的函数是显式的可重入函数</li>
<li>值传递和引用传递的函数是隐式可重入函数</li>
</ul>
<h4 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h4><ol>
<li>程序的正确性依赖于一个线程要在另一个线程到达y点之前到达x点，会引发竞争</li>
<li>为示例程序中的每个整数ID分配一个独立的块，并传递给线程例程必须释放这些块以避免内存泄露</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ol>
<li>一组线程被阻塞了</li>
<li>两个禁止区重叠部分的左下方，会导致死锁</li>
<li>程序员使用P和V操作顺序不当，所有阻塞的线程都在等待一个不会发生的V</li>
<li>死锁是不可预测的</li>
<li>使用二元信号量来实现互斥时，可以用互斥锁加锁顺序原则来避免死锁。给定所有互斥操作一个全序，如果每个线程都以一种顺序获得互斥锁并以相反的顺序释放，这种操作是无思索的</li>
</ol>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat.jpg" alt="WhitneyLu wechat" style="width: 200px; max-width: 100%;">
    <div>Contact me by scanning my public WeChat QR code</div>
</div>


      </div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/12/Linux内存系统/" rel="next" title="Intel Core i7/Linux内存系统">
                <i class="fa fa-chevron-left"></i> Intel Core i7/Linux内存系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/22/Effective_C++_1/" rel="prev" title="Effective C++ 1">
                Effective C++ 1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>

<script type="text/javascript" src="https://me.idealli.com/images/load.gif" data-src="/js/src/love.js"></script>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/nessa.png" alt="WhitneyLu">
            
              <p class="site-author-name" itemprop="name">WhitneyLu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:miracle960118@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#程序间交互和通信"><span class="nav-number">1.</span> <span class="nav-text">程序间交互和通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#系统级I-O"><span class="nav-number">1.1.</span> <span class="nav-text">系统级I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">1.1.1.</span> <span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打开和关闭文件"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">打开和关闭文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读和写程序"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">读和写程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取文件元数据"><span class="nav-number">1.1.2.</span> <span class="nav-text">读取文件元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取目录内容"><span class="nav-number">1.1.3.</span> <span class="nav-text">读取目录内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享文件"><span class="nav-number">1.1.4.</span> <span class="nav-text">共享文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O重定向"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">I/O重定向</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准I-O"><span class="nav-number">1.1.5.</span> <span class="nav-text">标准I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择合适的I-O"><span class="nav-number">1.1.6.</span> <span class="nav-text">选择合适的I/O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络编程"><span class="nav-number">1.2.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP地址"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">IP地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发编程"><span class="nav-number">1.3.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于进程的并发编程"><span class="nav-number">1.3.1.</span> <span class="nav-text">基于进程的并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于I-O多路复用的并发编程"><span class="nav-number">1.3.2.</span> <span class="nav-text">基于I/O多路复用的并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O复用的优势和劣势"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">I/O复用的优势和劣势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于线程的并发编程"><span class="nav-number">1.3.3.</span> <span class="nav-text">基于线程的并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程执行模型"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">线程执行模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Posix线程"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Posix线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建线程"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终止线程"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">终止线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分离线程"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">分离线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化线程"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">初始化线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于线程的并发服务器"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">基于线程的并发服务器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用信号量同步线程"><span class="nav-number">1.3.4.</span> <span class="nav-text">用信号量同步线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进度图"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">进度图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用信号量来调度共享资源"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">利用信号量来调度共享资源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用线程提高并行性"><span class="nav-number">1.3.5.</span> <span class="nav-text">使用线程提高并行性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#竞争"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">竞争</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">死锁</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-Whitney"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WhitneyLu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">74.6k</span>
  
</div>







        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "default";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "default";
      
          flOptions.boxForm = "vertical";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>

  

  

  

  

</body>
</html>
