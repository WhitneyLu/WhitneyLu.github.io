<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进程间通信]]></title>
    <url>%2F2019%2F06%2F13%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[进程间通信管道 父子进程之间不共享数据段和堆栈段，通过管道进行通信 管道是两个进程之间进行单项通信的机制，是一种半双工管道 管道只能用于具有亲缘关系的进程（父子进程和兄弟进程） 管道没有名字 管道的缓冲区大小受限制 管道传输的是无格式的字节流 两端进程向管道读写数据是通过创建管道时系统设置的文件描述符进行的，管道本质上也是一种文件 写数据每次都添加到管道缓冲区的末尾，读数据是从缓冲区的头部读出数据的 管道由函数int pipe(int fd[2]);函数创建，依赖头文件#include &lt;unistd.h&gt; 有名管道已FIFO的文件形式存在于文件系统中，即使访问该路径的进程不存在亲缘关系也可以通过FIFO相互通信 实现两个不相关进程之间的通信 该管道可以通过路径名指出，在文件系统中是可见的 FIFO严格的遵守先进先出原则，从管道头部读出数据，将写操作的数据添加到末尾123456#include &lt;sys/sypes.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); //pathname是路径名也就是创建后FIFO的名字，mode和open()函数中的mode参数//如果路径已经存在则返回EEXIST错误 消息队列 用于运行于同一条机器上的进程间通信，在一个系统内核中用来保存消息的队列，在系统内核中以消息链表的形式出现的 创建消息队列或取得已经存在的消息队列 123456789101112131415161718192021222324252627int msgget(key_t key, int msgflg); //key是端口号，也可以通过ftok函数生成//msgflg如果等于IPC_CREAT，如果没有该队列，则创建一个并返回一个标识符，如果已经存在则返回原标识符//msgflg等于IPC_EXCL，如果没有该队列返回-1，如果已经存在返回0ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);//从队列中取用消息//msqid是消息队列的标识码//msgp是指向消息缓冲区的指针//msgsz是消息的大小//msgstp是从消息队列中读取的消息形态，如果值为0表示消息队列中的所有消息都会被读取//msgflg用来指明核心程序在队列没有数据的情况下应该采取的行动struct msgstru&#123; long mtype; char mtext[512];&#125;;int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);//将数据放到消息队列中int msgctl(int msgqid, int cmd, struct msqid_ds *buf);//设置消息队列的属性//对msgqid表示的消息队列执行cmd操作//IPC_STAT来获取消息队列的msqid_ds数据结构，并保存到buf指定的地址空间//IPC_SET设置消息队列的属性，要设置的属性存储在buf中//IPC_RMID从内核中删除msqid标识的消息队列 消息队列和有名管道有相似之处，也有优势： 消息队列可以用于独立发送和接收进程而存在，消除同步有名管道打开和关闭可能产生的困难 可以同时通过发送信息来避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法 接收程序可以通过消息类型有选择的接收数据 共享内存12345678910111213141516#include &lt;sys/shm.h&gt;int shmget(key_t key, int size, int flag);//不相关的内存可以通过该函数的返回值访问同一个共享内存//key为共享内存段命名，函数运行成功，则返回一个与key相关的共享内存标识符，用于后续的共享内存函数，调用失败返回-1//size指定共享内存的容量void *shmat(int shmid, void *addr, int flag);//内存创建之后，其余进程可以调用shmat函数将其连接到自身的地址空间中//shmid为shmget函数返回的共享存储标识符//addr和flag参数决定以什么方式决定连接的地址，函数返回值是该进程数据段所连接的实际地址//不是原子操作，如果有多个程序同时向共享内存中读写数据，执行不安全int shmdt(const void *shmaddr);//函数用于从共享内存从当前进程中分离//参数shmaddr是函数shmat函数返回的地址指针，调用成功返回0，失败返回-1 信号量123456789101112131415161718192021222324252627282930313233#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int semflg);//用于创建和打开信号量//执行成功返回0，失败返回-1//参数key是调用ftok函数得到的键值//nsems代表创建信号量的个数，如果只是访问而不创建可以指定这个参数为0，一旦创建信号量就不能改变信号量的个数//只要不删除该信号量，就可以调用这个函数创建该键值的信号量，但是不能更新key的值//semflg执行该信号量的读写权限int semop(int semid, struct sembuf *sops, unsigned nsops);//用于改变信号量的值//sem_id是由semget返回的信号量标识符struct sembuf&#123; short sem_num; //除非使用一组信号量，否则就是0 short sem_op; //信号量在一次操作中需要改变的数据，-1表示等待操作，+1表示发送信号操作 short sem_flg; //通常是SEM_UNDO，使操作系统跟踪信号，在进程没有释放该信号量而终止时，操作系统释放信号量&#125;;int semctl(int semid, int semnum, int cmd, ...);//函数用来直接控制信号量信息//cmd通常是SETVAL或IPC_RMID//SETVAL用来把信号量初始为一个已知的值，p值通过union semun中的val，在信号量第一次使用前对它进行设置//IPC_RMID用于删除一个已经无需继续使用的信号量标识符//第四个参数通常是union semum结构union semun&#123; int val; struct semid_ds *buf; usigned short *arry;&#125;; ipcs命令 ipcs -a列出本用户相关的ipcs参数 ipcs -q列出进程中的消息队列 ipcs -s用于列出所有的信号量 ipcs -m用于列出所有共享内存信息 ipcs -l用于列出系统的险恶 ipcs -t列出最后的访问时间 ipcs -u列出当前的使用情况]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程程序和进程 进程是程序运行的实例，程序是可执行的二进制代码文件，将文件加载到内存中运行就得到一个进程，同一个程序文件家在多次称为不同的进程 进程包括三个部分：代码段、数据段、堆栈段。 代码段就是程序的代码数据，如果有多个进程运行同一个程序，则可以使用同一个代码段 数据段存放程序的全局变量、常量和静态变量 堆栈段中的栈用于函数调用，存放函数的参数、函数内部定义的局部变量。堆栈段还包括进程控制块(PCB) PCB处于进程核心堆栈的底部，PCB是进程存在的唯一标识 每个进程在系统中通过PID唯一的标识 进程的创建和结束 进程创建有两种方式：由操作系统创建、由父进程创建 init()函数在内核态运行，是内核代码 init进程是内核启动并运行的第一个用户进程，运行在用户态下 init函数调用execve()从文件/etc/inittab中加载可执行程序init并执行，这个过程没有调用do_fork() 进程创建 fork()函数12345#include &lt;unistd.h&gt;pid_t fork(void);//对于父进程，函数返回新创建的子进程的PID，对于子进程，创建成功则返回0//创建失败返回-1 调用fork()函数的就是父进程，新创建的进程就是子进程 为新创建的子进程分配进程空间，将父进程的空间中的内容复制到子进程的进程空间，包括数据段和堆栈段，两者共用代码段 getpid()获得当前进程的PID，getppid()获得父进程的PID 进程结束 exit()函数12345#include &lt;stdlib.h&gt;void exit(int status);//status是一个整型状态值，表示进程的退出状态，保存在全局变量$?中//$?保存main函数的返回值，或者程序运行中调用exit的status的值，或者异常出错的错误号 exit()是一个函数，执行完成后将控制权交给系统，而return完成后将控制权交给调用函数 exit是正常终止，abort是异常终止 exit在stdlib.h中声明，_exit在unistd.h中声明 exit参数为0表示进程正常终止，如果是其他值则表示执行过程中有错误发生 _exit在执行后立即返回给内核，会关闭所有的文件描述符，清理内存以及其他一些内核清理函数，但是不会刷新流。exit()要先执行一些清除操作，然后才将控制权交给内核，是在_exit函数基础上的一个封装，会在调用_exit函数之前先刷新流数据，有利于将缓冲区的数据正确写入文件，如printf()函数就是一个使用缓冲IO的方式 僵尸进程 孤儿进程是指，父进程退出后，有子进程还在运行，这些子进程就是孤儿进程，这些进程将会被init进程（进程号PID=1）的进程收养 僵尸进程，是指进程使用fork创建紫禁城，如果子进程退出，而父进程没有调用wait或者waitpid获取子进程的状态信息，则子进程的进程描述符仍然保存在系统中，这种进程称为僵尸进程 孤儿进程是子进程未退出，父进程已退出。僵尸进程是子进程已退出，父进程未退出 调用wait函数，可以自动分析当前进程的某个子进程已经退出，wait可以回收子进程，销毁后返回，如果没有这样的子进程wait就会一直阻塞在这里，直到有一个出现1234567#include &lt;sys/tyoes.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int *status);//wait会暂时停止目前进程的执行明知道有信号或者子进程结束/*如果在调用wait时已经有子进程结束，则wait会立即返回子进程结束状态值，子进程结束状态值由参数status返回，子进程的进程识别码也会一起返回，如果不需要结束状态值，则参数status可以设为NULL*///执行成功则返回子进程识别码PID，如果错误返回-1，并将错误原因存在errno 12345678910111213141516171819202122232425262728293031323334353637#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main() &#123; pid_t pid=fork(); if(pid&lt;0) &#123; perror(&quot;fork error\n&quot;); return 0; &#125; else if(pid&gt;0) &#123; printf(&quot;Parent process\n&quot;); int status=-1; pid_t pr=wait(&amp;status); //等待子进程？ if(WIFEXITED(status)) &#123; //sleep(10); printf(&quot;the child process %d exit normally.\n&quot;, pr); printf(&quot;the return code is %d.\n&quot;, WEXITSTATUS(status)); &#125; else &#123; printf(&quot;the child process %d exit abnormally.\n&quot;, pr); &#125; &#125; else if(pid==0) &#123; printf(&quot;Sub-process, PID: %u, PPID: %u\n&quot;, getpid(), getppid()); exit(3); //WIFEXITSTATUS(status)返回5 &#125; return 0;&#125; waitpid是wait的封装，多出两个可由用户控制的参数pid和options123456789101112131415#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *status, int options);//暂时停止目前进程的执行，直到有信号来到或子进程结束//pid是等待的子进程的识别码，pid&lt;-1等待进程组识别码为pid绝对值的任何子进程//pid=-1等待任何子进程，相当于wait//pid=0等待进程组识别码与目前进程相同的任何子进程//pid&gt;0等待任何子进程识别码为pid的子进程//options=WNOHANG及时没有子进程退出，立即返回//options=WUNTRACED，子进程进入暂停则马上返回，结束状态不予理会//正常返回时返回收集到的子进程的进程ID//如果设置了WNOHANG，调用中waitpid发现没有已退出的子进程可手机则返回0//如果调用中出错，则返回-1，errno被设置成相应的值指示错误//pid指示的子进程不存在，若进程存在，但不是调用进程的子进程，waitpid就会出错返回，errno被设置成ECHILD？ 守护进程 守护进程是脱离终端并且在后台运行的进程 创建简单的守护进程： 创建子进程，父进程退出 在子进程中创建新会话，使用系统函数setsid创建一个新会话，并担任会话组组长setsid() 改当前目录为根目录chdir() 重设文件权限位掩码为0，用umask(0) 关闭文件描述符]]></content>
      <categories>
        <category>进程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2019%2F06%2F11%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程 对于每个进程，系统资源都是独立的，频繁的切换进程产生额外的开销严重影响系统性能 类似于交互性的GUI程序，如果每个任务都由进程来实现，就会非常低效 每一个进程内部的多个线程共享进程的上下文资源 一个程序运行过程中，只有一个控制权，函数被调用时，该函数获得控制权，成为激活函数 多线程允许一个进程内存存在多个控制权，以便让多个函数同时处于激活状态，允许多个函数操作同时运行 栈后进先出，只有最下方的帧可以被读写，创建一个新线程的时候传建一个新的栈，每个栈对应一个线程。某个栈执行全部弹出之后，对应线程完成并结束 如上所述，多线程的进程在内存中有多个栈，多个栈之间用一定的空白区域隔开 每个线程调用自己栈最下方的帧中的参数和变量，并与其他线程共享内存中的Text、heap和global data区域 线程的创建和结束123456789101112131415161718192021222324#include &lt;pthread.h&gt;int pthread_creat(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)； /* *thread是指向线程标识符的指针*/ /* *attr设置线程属性，指定不同的线程属性*/ /* 第三个参数是线程运行函数的起始地址*/ /* *arg是运行函数的参数*//*若线程创建成功，则返回0。thread指向的内存单元被设置为新创建线程的线程ID，新创建的线程从*start_routine函数的位置开始执行*//*线程创建出错，返回出错编号，新创建的线程从*start_routine*/int pthread_join(pthread_t thread， void **retval)； //函数等待一个线程结束 //thread表示被等待的线程标识符 //**retval为用户定义的指针，用来存放被等待线程的返回值 //这个函数是线程阻塞函数，调用它的函数一直等待到被等待的线程结束为止，函数返回时，被等待的线程的资源被回收 void pthread_exit(void *retval); //函数结束，调用它的线程结束 //pthread_join由主线程来调用，等待子线程退出，pthread_exit由子线程调用，用来结束当前线程 //子线程通过pthread_exit传递一个返回值，主线程通过pthread_join来或者该返回值来判断该子进程的退出是正常还是异常 //获得线程ID，在线程调用函数使用pthread_self获得，或者在创建函数时生成的ID 线程的属性 线程有一组属性可以在线程被创建时指定，改组属性被封装在一个对象中，对象可以用来设置一个或一组线程的属性 线程属性对象的类型为pthread_addr_t 属性值不能直接设置，必须使用相关函数进行操作，初始化的函数为pthread_addr_init 进程地址空间不够用时，指定新建线程使用malloc分配的空间作为自己的栈空间 多线程同步互斥锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;//pthread_mutex_t mutex_x= PTHREAD_MUTEX_INITIALIZER; //互斥锁int total_ticket_num=20; //全局变量void *sell_ticket(void *arg)&#123; for(int i=0; i&lt;20; ++i) &#123; //pthread_mutex_lock(&amp;mutex_x); //使用互斥锁将对total_ticket_num的操作进行加锁 if(total_ticket_num&gt;0) &#123; sleep(1); total_ticket_num--; printf(&quot;sell the %dth ticket\n&quot;,20-total_ticket_num); &#125; //pthread_mutex_unlock(&amp;mutex_x); //使用互斥锁将对total_ticket_num的操作进行解锁 &#125; return 0;&#125;int main()&#123; int iRet; pthread_t tids[4]; int i=0; for(i=0; i&lt;4; ++i) //四个线程 &#123; int iRet=pthread_create(&amp;tids[i], NULL, &amp;sell_ticket, NULL); //创建成功返回0，&amp;sell_ticket线程运行函数的起始位置 if(iRet) &#123; printf(&quot;pthread_creat error, iRet=%d\n&quot;,iRet); return iRet; &#125; &#125; sleep(20); void *retval; for(i=0; i&lt;4; ++i) &#123; iRet=pthread_join(tids[i], &amp;retval); if(iRet) &#123; printf(&quot;tid=%d join error, iRet=%d\n&quot;, tids[i], iRet); return iRet; &#125; printf(&quot;retval=%ld\n&quot;, (long*)retval); &#125; return 0;&#125; 未加互斥锁之前产生竞争，并且出现票超卖 加互斥锁后 创建互斥锁有动态和静态两种，上述的加锁方式是静态的 锁可以用pthread_mutex_init动态地创建 条件变量 使用条件变量来阻塞一个进程，当条件不满足时，线程需要解开互斥锁并等待条件发生变化 条件变量也有静态和动态两种创建方式 123456789pthread_cond_t cond=PTHREAD_COND_INITIALIZER; //静态int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr); //动态，当cond为NULL时，使用默认属性int pthread_cond_destory(pthread_cond_t *cond); //注销一个条件变量int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); //等待int pthread_cond_timewait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime); //条件等待//这两种等待都必须和互斥锁配合防止多个线程同时请求等待产生竞争pthread_cond_singal(); //激活一个等待该条件的进程，存在多个等待进程时，按照顺序激活其中一个pthread_cond_broadcast(): //激活所有等待线程 在某些情况下，使用条件变量没有掌握好触发的时机，可以使用计数器来记录等待的线程的个数，在决定触发条件变量前先检查该变量 读写锁 可以哟多个线程同时占用读模式，但是只允许一个线程占用写模式 写加锁状态，这个锁被解锁之前，所有对这个锁加锁的线程都会被阻塞 读加锁状态，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程都会被阻塞 读模式的锁栈状态，当有线程以写模式加锁时，读写锁对随后的读模式锁的请求阻塞，避免读模式锁被长期阻塞 读写锁适用于对数据结构的读操作次数大于写操作次数的场合 读写锁有两种初始化方式： 通过静态分配的读写锁赋予常值PTHREAD_RWLOCK_INITIALIZER 调用pthread_rwlock_init()动态的初始化，如果执行成功则返回0，出错则返回出错码int pthread_rwlock_init(pthread_rwlock_t *rwptr, const pthread_rwlockattr_t *attr); 当线程不需要读写锁的时候，调用pthread_rwlock_destory()，如果执行成功则返回0，出错则返回出错码int pthread_rwlock_destory(pthread_rwlock_t *rwptr); 读写锁的数据类型是pthread_rwlock_t123456789pthread_rwlock_rdlock(pthread_rwlock_t *rwptr); //用来获取读出锁，如果相应的读出锁被某个写入者占有，则阻塞调用线程pthread_rwlock_wrlock(pthread_rwlock_t *rwptr); //用来获取写入锁，如果相应的写如梭被其他写入锁和读出者占用，则阻塞该调用线程pthread_rwlock_unlock(pthread_rwlock_t *rwptr); //用来释放一个读出锁或者写入锁//以上三个函数都是阻塞式的，如果获取不到锁，调用线程不是立即返回的，调用线程投入到睡眠等待//调用成功返回0，调用失败返回错误码//非阻塞式的读写锁的函数，如果不能马上获取到，立即返回EBUSY错误提示pthread_rwlock_rdlock(pthread_rwlock_t *tryrwptr); pthread_rwlock_wrlock(pthread_rwlock_t *tryrwptr); 信号量 互斥锁只允许一个线程进入临界区，信号量允许多个线程进入临界区 要使信号量同步，需要包含头文件semaphore.h12345int sem_init(sem_t *sem, int pshared, unsigned int value); //初始化sem指向的信号对象，设置它的共享选项，并给它一个初始的整数值，pshared=0表示这个信号量是当前进程的局部信号量，否则信号量在多个进程之间共享int sem_wait(sem_t *sem); //用于以原子操作的方式将信号量的值-1int sem_post(sem_t *sem); //用于以原子操作的方式将信号量的值+1int sem_destory(sem_t sem); //用于对用完的信号量进行清理 多线程可重入 可重入函数的特点： 不为连续的调用持有静态数据 不返回指向静态数据的指针 所有数据都由函数的调用者提供 使用本地数据，或者通过制作全局数据的本地副本来保护全局数据 必须调用全局变量时，要利用互斥锁和信号量来保护全局变量 不调用任何不可重入函数 可重入代码可以被多次调用而仍然正常工作 编写的多线程程序，通过定义宏_REENTRANT告诉编译器需要可重入功能 _REENTRANT做的三件事 为部分函数重新定义的可安全重入的版本 stdio.h中的原来以宏的形式实现一些函数将变成可安全重入的函数 在error.h中定义的变量error现在将成为一个函数调用，以一种安全的多线程方式来获取真正的errno的值]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络IO模型]]></title>
    <url>%2F2019%2F06%2F09%2F%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[网络IO模型 同步I/O是必须等待IO操作完成后，控制权才返回用户进程 异步I/O是无需等待IO操作完成就将控制权返回给用户进程 一个网络IO涉及两个系统对象，当一个read操作发生时，会经历两个阶段：等待数据准备；将数据从内核拷贝到进程中 阻塞IO模型 Linux中默认情况下，所有的socket都是默认阻塞的，大部分socket接口都是阻塞的 在服务器端使用多线程或是多进程，使单个连接的阻塞不会影响其他连接 多进程的开销较大，为教唆客户提供服务时，通常使用多线程 使用pthread_creat()创建新线程，使用fork()创建新进程 服务器实现一对多连接，主进程持续等待客户端的连接请求，如果有连接创建新线程 使用线程池降低创建和销毁线程的频率，维持一定数量的线程 非阻塞IO模型 使用非阻塞模型来提高使用效率 fcntl(fd, F_SETFL, O_NONBLOCK); recv()函数在被调用后立即返回 返回值大于0，接收数据完毕，返回值即是接收到的字节数 返回0，表示连接已断开 返回-1，且errno等于EAGAIN，表示recv操作还没执行完成 返回-1，且errno不等于EAGAIN，表示recv操作遇到系统错误errno 多路IO复用模型 基本原理是有个函数(select())会不断轮询所负责的所有socket，当用户进程调用了select整个进程被阻塞，当任何一个socket中的数据准备好了，select就会返回，用户进程调用read，将数据从内核拷贝到用户进程 多路IO复用模型中，对于每一个socket一般都设置为非阻塞的，但是进程被select函数阻塞 select()能够检测来自客户端的connect() select的参数readfds按照bit为标记描述字 writefds和exceptfds应该标记所有需要检测的可写数据和错误时间的的标记，使用FD_SET() 用FD_ISSET()检查所有的标记位 select不适合用来实现事件驱动 异步IO模型 用户发起read操作之后，开始做其他事，从内核的角度当他收到一个异步的read操作之后，立即返回，不会对用户进程产生任何阻塞，内核等待数据准备完成后，然后将数据拷贝到用户内存中，内核给用户进程发送一个信号，返回read操作已完成的信息 selectselect(int maxfdp, fd_set *readfds, fd_set *writefds, 12345678910 fd_set *errorfds, struct timeval *timeout); /*fd_set是文件描述符集合*/ /*timeval有两个成员，一个是秒数，一个是毫秒数*/ /*maxfds是一个整数值，是集合中所有文件描述符的范围*/ /*readfds是指向fd_set结构的指针，如果集合中有一个文件可读，select就会返回一个大于0的值，如果没有可读文件的，根据timeout参数判断是否超时，如果超时返回0，如果发生错误返回负值*/ /*wretefds是指向fd_set结构的指针，监视文件描述符的写变化，如果集合中有文件可写，返回一个大于0的值，如果没有，根据timeout参数判断是否超时，如果超时返回0，如果发生错误返回负值*/ /*timeout是select的超时时间，如果引入NULL以形参传入，表示不传入时间结构，将select置为阻塞状态，知道文件集中的某个文件描述符发生变化位置 /*若将时间值设为0，变成非阻塞函数，不管文件描述符如何变化都立即返回，无变化返回0，有变化返回一个正值如果将timeout大于0，select在等待时间内阻塞，超时时间内有事件到来后返回，否则在超时后返回，超时返回0，出错返回-1*/ poll poll也能用来执行多路复用 123456789101112#include &lt;poll.h&gt;int poll(struct pollfd *fds, unsigned int nfds, int timeout); //timeout指定等待的毫秒数，无论IO是否准备好，poll都会返回 //timeout指定为负数值时，表示无限超时，poll一直挂起知道某件事发生 //timeout为0表示poll调用立即返回，并列出准备好IO的文件描述符 //调用成功，函数返回revents域中国不为0的文件描述符的个数 //如果在超时前没有任何事件发生，返回0，失败返回-1，并设置errnostruct pollfd&#123; int fd; short events; //监视文件描述符的时间掩码，由用户来设置这个域的属性 short revents; //文件描述符的操作结果事件掩码，内核在调用返回时设置这个域&#125;; 每个pollfd结构体指定一个被监视的文件描述符，可以传递多个结构体只是poll()监视多个文件描述符 在events域中请求的事件都有可能在revents中返回 poll不需要显式的请求异常情况报告 select所用的描述符集合是fd_set的结构体中，poll的描述符存放在pollfd数组中 epoll epoll使用户一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中 在用户空间和内核空间之间的数据只需要拷贝一次1234567891011121314#include &lt;sys/epoll.h&gt;//包含三个接口int epoll_creat(int size);/*告诉epoll内核要监听的数目，是最大监听fd+1*/int epoll_stl(int epfd, int op, int fd, struct epoll_event *event);/*事件注册函数，epfd是epoll_creat的返回值，op表示动作，fd表示要监听的文件描述符，*event告诉内核监听什么事*/int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);/*等待时间产生，events用来表示从内核得到事件的集合，maxevents告诉内核这个events有多大，且不能大于size，timeout是超时时间*/struct epoll_event&#123; _unit32_t events; epoll_data_t data;&#125;; select、poll和epoll的区别和各自的优缺点 select、poll和epoll都是多路复用，本质上都是同步IO poll不要求在计算开发者最大文件描述符时进行+1操作 poll应付大数目的文件描述符时更快，select()需要内核检查大量描述符对应的fd_set中的每一个比特位 select()监控的文件描述符的数目是固定的，poll可以创建特定大小的数组来保存监控的描述符，不受文件描述符值的大小的影响，poll可以监控的文件描述符的数量远大于select fd_set会在select()返回之后变化，在下一次进入select之前需要重新初始化需要监控的fd_set。poll将被监控的输入和输出分开，允许被监控的文件组数被复用而不需要重新初始化 select函数的超时参数在返回时也是未定义的，每次超时进入到select之前都需要重新设置超时参数 select优点:select可移植性很好，具有较好的超时值精度 epoll优点：支持进程打开大数目的socket描述符，IO效率不随socket描述符的增加而线性下降，因为epoll只对活跃的socket进行操作，使用mmp加速内核与用户空间的信息传递，内核通过内核与用户空间mmap处于同一块内存实现的 poll将用户传入的pollfd数组拷贝到内核空间的拷贝操作和数组长度相关，是O(n)操作，像用户空间拷贝数据和剥离等待队列等操作的时间也是O(0)]]></content>
      <categories>
        <category>网络IO模型</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP的区别]]></title>
    <url>%2F2019%2F05%2F28%2FTCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[TCP和UDP的区别]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP]]></title>
    <url>%2F2019%2F05%2F25%2FTCP%2F</url>
    <content type="text"><![CDATA[TCP头部 一个TCP连接由一个4元组组成，由一对套接字构成，套接字是由IP地址和端口组成的，被称为socket；每个TCP连接由一对套接字唯一的标识 序列号字段唯一的标识了TCP发送端到TCP接收端的数据流的一个字节，代表报文段的数据中的第一个字节，处理被传送分组的重复和传送顺序。基于窗口的流量控制，窗口大小可以随时间变化，称为窗口通告，接收方的窗口通告夹带着发送方的窗口大小值 确认号字段是发送方期待接收的下一个序列号加1，这个字段只有在ACK位字段被启用的情况下才有效，选择确认选项高速发送方正确接收到次序杂乱的数据 头部长度限制了TCP至多只能携带60位的头部 16位限定了窗口大小至多65535字节，限制了TCP的吞吐量性能。定义分组窗口作为已发送还未被接收的分组的集合，窗口大小是分组数量，ACK反向流动 ACK表示确认号是否有效，TCP使用的ACK是累积的，1）是否接收到分组；2）接收方接收到的是否和发送方发送的一致 PSH表示接收端应用程序应立即从TCP接收缓冲区中读走数据；RST表示要求对方对方重新建立连接；SYN表示请求建立一个连接；FIN表示通知对方本端要关闭连接了 TCP校验和字段覆盖了TCP的头部和数据以及头部中的一些字段，TCP会丢弃一个带无效校验和的报文段 紧急指针只在URG字段被设置时才有效，是必须被加到报文段的序列号字段上的正偏移，产生紧急数据的最后一个字节的序列号。这是发送方提供给另一端的特殊标志数据的方法 最常见的选项字段是最大段大小选项称为MSS，连接的每个端点基本上都在它发送的第一个报文段上指定这个选项，指定接收方希望接收到的报文段的最大值 SO_RESEADDR可以用来设定端口释放后可以立即被使用；位于TIME_WAIT状态的套接字重复绑定使用，server程序在bind()之前设置这个TCP选项 SO_LINGER可以改变close的行为 12345678struct linger&#123; int l_onoff; //设置为0时，选项被关闭 int l_linger; /*l_onoff非0时，l_linger为0，close()不被阻塞立即执行，丢弃缓冲区数据，向对端发送一个RST报文，这种关闭方式被称为强制关闭*/ /*l_onoff非0，l_linger为非0，close()调用阻塞进程，知道所剩数据发送完毕或超时，如果socket()被设置为O_NONBLOCK状态，程序将不会等待close返回*/ /*如果在发送端缓冲区的所有数据被发送之前且延迟时间没有消耗完，close将会返回EWOULDBLOCK*/ &#125;; TCP的连接和终止 TCP的连接和终止分别对应著名的三次握手和四次挥手 三次握手 四次挥手 TCP拥塞机制 慢开始、拥塞避免、快速重传、快速恢复 发送方维护拥塞窗口cwnd，开始时cwnd=1，每经过一个RTTcwnd+1，每次传输轮次后cwnd按指数增长 慢开始门限ssthress，当cwnd&gt;ssthress时，执行拥塞避免算法，cwnd线性增长 网络拥塞时，将ssthress设为原来的一半，cwnd重置为1 快速重传要求对方接收到一个失序报文断后立即发出重复确认，发送方持续受到三个重复确认就将ssthress减半，但不执行慢开始算法，将cwnd设为ssthress 滑动窗口 发送窗口收到对端窗口内字节的ACK确认才会移动窗口的左边界 应用程序通过API通知TCP协议栈缩小TCP接收窗口，对端按照通知的窗口来改变发送窗口 重传超时时间RTO 自适应重传算法：按照当前RTT的准确估计来调整RTO karn算法：新RTO=γ*旧RTO，γ典型值为2 不再重传时，更新平均RTT和重传时间的数值]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F05%2F15%2FHTTP%2F</url>
    <content type="text"><![CDATA[应用层协议 HTTP Web的应用层协议是HTTP HTTP由两个程序实现：客户程序和服务器程序 HTTP使用TCP作为支撑运输协议，HTTP客户首先发起一个与服务器的TCP连接，连接建立起来之后，浏览器和服务器进程就可以通过套接字接口访问TCP，TCP为HTTP提供可靠的数据传输服务 服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议 HTTP默认持续连接，但是HTTP客户和服务器可以被配置成非持续连接 非持续连接：每个TCP连接服务器发送一个对象后关闭，每个TCP连接只传输一个请求报文和一个响应报文 浏览器可以打开5-10个并行的TCP连接，并行连接可以缩短响应时间 往返时间RTT，是指一个短分组从客户到服务器然后再返回客户所花的时间。一次TCP连接涉及三次握手过程，三次握手的前两个部分消耗时间占用了一个RTT。客户结合第三部分向TCP连接发送一个HTTP请求报文，请求报文到达服务器，服务器就在该TCP连接上发送HTML文件，这个HTTP请求/响应用去了另一个RTT 持续连接的HTTP：服务器在发送响应后保持该TCP连接打开，在相同的用户和服务器之间，后续的响应的请求报文能够通过相同的连接进行传送 在持续连接中，一个完整的Web页面可以通过单个持续的TCP连接完成 如果一条连接经过一段时间间隔没有被使用，HTTP服务器就关闭该连接 cookie cookie有四个组件分别在请求报文、响应报文、用户端系统、Web站点的后端服务器中保存 cookie用于标识一个客户，Web站点为每一个客户分配一个唯一的标识码，作为索引后端数据中的表项 cookie允许对用户进行追踪或根据访问信息投放广告，被人为是侵犯用户隐私的 Web缓存 Web缓存器又称为代理服务器 Web缓存器既是服务器又是客户，浏览器请求对象，Web缓存器先检查本地有没有这个对象，如果有就返回这个对象，如果没有就向对象的初始服务器打开TCP连接，Web缓存器在本地保存对象的副本，然后向客户的浏览器用HTTP响应报文发送副本 Web缓存器可以减少客户请求的响应时间，可以减少一个机构的接入链路到因特网的通信量，改善所有用户的性能 通过使用内容分发网络，Web缓存器在因特网中发挥着巨大作用 HTTP请求报文和响应报文报文由普通ASCII码书写 12345678#HTTP请求报文GET /somedir/page.html HTTP/1.1 #请求行由三个字段组成：方法字段，URL字段和HTTP版本字段#下面是首部行Host: www.someschool.edu #指明了对象所在的主机Connection: close #表示使用非持续连接User-agent: #指明向服务器发送请求的浏览器的类型Accept-language: #表示用户得到该对象的语言版本#实体体 使用GET方法时，实体体为空，使用户POST时，才能使用实体体 123456789101112#HTTP响应报文HTTP/1.1 200 OK #初始状态行有三个字段，HTTP协议版本，状态码和响应的状态信息#200 OK 请求成功 301 Moved Permanently 请求对象已经被永久转移了 ...#下面是6个首部行Connection: close #发送完报文后关闭TCP连接Date: Tue, 18 Aug 2015 15:44:04 GMTSever: Apache/2.2.3 (CentOS) #指示产生报文的服务器Last-Modified: Tue, 18 Aug 2015 15:11:03 GMTContent-Length: 6821 #被发送对象的字节数Content-Type: text/html #指示实体体中的对象是HTML文件(data data data...) #实体体]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础1]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[计算机网络基础 所有接入因特网的设备都可以被称为端系统 端系统通过通信链路和分组交换机连接到一起 有两种分组交换机：路由器、链路层分组交换机，路由器位于网络层，链路层分组交换机位于链路层 电路交换和分组交换 电路交换在端系统通信期间，预留了通信路径所需要的资源，保持恒定的传输速率，可以采用时分复用和频分复用 分组交换资源不预留，端到端时延不可预测，但是相比电路交换实现了更好的资源共享 分组交换在路径中遇到的时延：节点时延，排队时延，传输时延，传播时延，所有时延相加就是节点总时延 分组交换的流量强度：La/R（a是分组到达队列的平均速率，R是传播速率，分组由L个比特组成），如果流量强度大于1，排队时延将会趋于无穷大 队列只能容纳有限分组，流量强度趋于1时，队列已满，到达分组无法进入队列，将会发生分组丢弃 计算机五层网络模型]]></content>
      <categories>
        <category>五层网络模型</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 2]]></title>
    <url>%2F2019%2F04%2F28%2FEffective_C%2B%2B_2%2F</url>
    <content type="text"><![CDATA[Effective C++ 条款26-555. 实现条款26：尽可能延后变量定义式出现的时间 确定需要一个对象时再定义它并赋以初值，以免产生不必要的构造和析构成本 增加程序的清晰度并改善程序效率 条款27：尽量少做转型动作 const_cast&lt;T&gt;将对象的常量性转除 dynamic_cast&lt;T&gt;执行向下转型，用来决定某对象是否归属继承体系中的某个类型 reinterpret_cast&lt;T&gt;执行低级转型，实际动作取决于编译器，不可移植 static_cast&lt;T&gt;强迫隐式转换 以上四种新式转型，在代码中更容易被识别出来，转型动作的目标更加窄 转型并不是什么都不做，不管是隐式转换还是显式转换真的令编译器编译处运行期间执行的代码 单一对象可能拥有一个以上地址，通过偏移量在两个地址见切换，但是这种偏移量计算地址的行为具有不可移植性 如果派生类的成员函数要求先调用基类的成员函数，使用转型可能会出错，在书119页的例子中，实际操作是在当前对象的基类成分的副本上调用Window::onResize dynamic_cast的许多实现版本执行速度都很慢，深度继承或多重继承的成本更高，在认定为派生类对象身上执行派生类成员函数，但是只有指向基类的指针或者引用，为了避免这种操作，采用以下两个做法 在容器中存储直接指向派生类的指针，而不需要通过基类接口处理对象的需要，但是这种做法无法再同一个容器内存储指针，要处理多种窗口类型，可能需要多个容器，必须具备类型安全性 通过基类接口处理所有可能的各种Window派生类，在基类内提供virtual函数做所有相对派生类做的事情 避免连串的dynamic_cast，这样产生代码又大又慢且基础稳 优秀的C++代码很少使用转型 条款28：避免返回handles指向对象内部成分 成员变量的封装性最多只等于“返回其引用”的函数访问级别 如果const成员函数传出一个reference，引用所指的数据和对象自身有关联，函数的调用者可以修改这个数据 引用、指针、迭代器都是号码牌（handle），返回代表对象内部数据的handle会降低对象的封装性，虽然成员函数是const却造成对象仍然状态仍然可以被修改 对象内部数据就是成员变量，不被公开的成员函数也是对象内部的一部分，这就意味着不要令成员函数指向访问级别较低的成员函数 将返回类型限制为const，客户可以访问对象的内部数据，但是不可以修改它们 但是这种情况还可能导致空悬额handle 条款29：为“异常安全”努力是值得的 异常安全的函数有一下性质：不泄露任何资源；不允许数据破坏 确保互斥锁会被安全释放 异常安全码必须保证三种中的一种：1）基本承诺，如果异常抛出，程序内的所有事物仍然保持在有效状态下；2）强烈保证，如果函数成功则完全成功，如果失败则返回到函数调用之前的状态；3）不抛掷保证，承诺不抛出异常 用智能指针管理成员变量，删除动作在新图像被成功创建之后发生，r1::shared_ptr::reset函数只有在其参数Image被成功生成之后才会被调用std::tr1::shared_ptr&lt;Image&gt; bgImage; bgImage.reset(new Image(imgSrc)) delete值在函数reset函数内被使用，如果这个函数从未被调用，则delete就不会发生 使用copy and swap策略，为要修改的原件创建一个副本，在副本上做改变，如果修改动作抛出异常，原对象没有发生改变，所有改变都成功用副本替换原对象 在函数内还包括另外两个函数，将会产生连带影响，如果这两个函数对非局部数据有连带影响时，很难提供强烈保证 如果系统内有一个函数不具备异常安全性，则整个系统都不具备异常安全性 条款30：透彻的了解inline，并且慎重的使用它们 inline函数免除函数调用成本，本质上是将对函数的每一个调用都用函数本体替换，这样做会增加目标码的大小 inline是对编译器的申请而不是强制命令，大部分编译器会拒绝太过复杂的内联函数 隐喻的方式是将函数定义在类定义式内部 明确声明的方法是在函数声明前面加上inline inline函数通常被放在头文件中，大部分inline函数都在C++编译器完成， template通常也被放在头文件中 virtual函数的调用也会是inline函数的调用落空 编译器可能不会通过函数指针对内联函数进行调用 构造函数和析构函数在调用过程中会发生一些无法预料的事情，不要将它们设置为inline inline函数无法随程序库的升级而升级 一开始不要讲任何函数设置为inline，除非是必须设置为inline的或者是平淡无奇的（隐喻）内联函数 将大多数inline使用在小型、被频繁使用的函数上 不要因为函数模板出现在头文件中就将它设置为inline，有一些建置环境在连接期才能执行模板的具现化 条款31：将文件间的编译依存关系降至最低 类的定义文件和含入文件形成了编译依存关系，如果头文件中有一个发生了改变，则所有含入或使用类的文件都要重新编译，这种连串编译依存关系会对许多项目造成难以形容的灾难 需要实现的是，在类的接口被修改过后，才需要被重新编译 以声明的依存性替换定义的依存性，将一个类分为两个类，一个只提供接口、一个负责实现接口 尽可能使用对象的引用或者指针传递，用类的声明式代替定义式 将class定义式从函数声明所在的头文件转移到内含函数调用的客户文件，将并非真正必要的类型定义与客户端之间的编译依存性去除掉 为声明式和定义式提供两个不同的头文件，程序库客户通常#include一个声明文件而不是前置声明若干函数，这样的类称为handle classes 另一种方法是令实现函数是抽象基类，一一描述派生类的接口，不带成员变量和构造函数，只有一个虚析构函数和一组纯虚函数用来描述所有接口。抽象基类内允许出现非虚函数，这种非虚函数在继承体系内的所有类内的实现都相同 抽象基类的客户必须有办法为这种类创建新的对象，用工厂函数或者虚构造函数，返回指针或者智能指针指向动态分配的对象，对象支持抽象基类的接口， 这类函数通常抽象基类内被声明为static 具象类必须被定义出来，且真正的构造函数必须被调用 具象类实现：1）从抽象基类继承接口规格，然后实现出接口覆盖的函数；2）多重继承 6. 继承与面向对象的设计条款32：确定public继承塑模出是一种关系 class D: public B，可以说D也是一种类型为B的类，反之则不行，说明B比D更具一般性 要保证D有B的所有特性，基类的每一件事也要适用于派生类 条款33：避免遮掩继承来的名称 内层作用域的名称会遮掩外层作用域的名称 派生类的作用域嵌套在基类作用域内 如果派生类的函数将基类的函数遮掩掉，则从名称查找的观点来看，基类的同名函数不在被继承 这种行为是为了避免从程序库或者框架内建立新的派生时从疏远的基类重载函数 使用using Base::mf1; //使基类内所有名为mf1的东西都在派生类内可见 如果是私有继承中，不想要调用某个函数，可以使用隐喻inline的转交函数遮掩 也可以使用inline转交函数将不支持using声明的编译器的函数汇入派生类作用域内 条款34：区分接口继承和实现继承 客户不能创建抽象类的实体，只能创建它的派生类的实体 成员函数的接口总会被继承 纯虚函数有两个突出特性：1）必须被任何继承他们的具象class重新声明；2）在抽象类中没有定义 声明纯虚函数的目的是让派生类只继承函数接口 可以为纯虚函数提供定义，但是调用时必须明确指出class的名称，Shape::draw 为非纯虚函数提供更加平常、安全的缺省实现 派生类继承非纯虚函数的接口，非纯虚函数提供一份实现代码，派生类可能会覆写它 切断虚函数和缺省实现之间的连接，没有对虚函数指定行为，将虚函数改为纯虚函数，仅提供飞行接口，定义了defaultFly，如果想要使用缺省实现，在派生类中的fly函数inline调用defaultFly 类C必须提供自己的fly版本 defaultFly是一个非虚函数 定义纯虚函数，然后在派生类中拥有一份自己的定义 基类中的非虚函数表现出不变性，不论派生类表现出多大的特异性，他的行为都不可改变 根据实际需求选择三种不同的成员函数，不要将函数全部声明为非虚函数，也不要全部声明为虚函数 条款35: 考虑虚函数以外的其他选择一、借由non-virtual interface实现NVI模式 保留成员函数为共有非虚函数，调用一个在私有部分定义的虚函数来完成操作，这个虚函数可以通过派生类重新定义 这种在公有非虚成员函数中调用私有虚函数的称为(non-virtual interface NVI)，就是所谓的Template Method设计模式的一种表现形式，将这个非虚函数称为虚函数外覆器 在类内部完成定义的成员函数是隐喻的inline 外覆器确保在虚函数被调用之前设定好场景，并在调用结束之后清理场景 NVI手法下没有必要虚函数没有必要一定得是虚函数 二、借由函数指针实现Strategy模式 同一人物的不同类型实体可以有不同的健康计数函数 已知任务的健康指数计算函数可以在运行期变更 健康指数计算函数不再是类继承体系内的成员函数，这些计算函数没有特别访问计算对象的内部成分 这些函数没有访问对象的非公有信息，如果这些函数需要非公有信息的精确计算，只能通过弱化class的封装 三、借由tr1::function完成Strategy模式 对象可以持有任何可调用物，如函数指针、函数对象或成员函数指针，只要其签名式兼容于需求端 int (const GameCharacter&amp;)表示接受一个const GameCharacter的引用并返回int 兼容的意思是调用对象类型和返回类型可以通过隐式转换复合要求 如果以tr1::function替换函数指针，将允许客户计算人物健康指数时使用任何兼容的可调用物 四、古典的Strategy模式 两个继承体系的基类，其中一个的类的每一个对象都包含一个指针指向来自另一个继承体系的对象 用继承体系内的虚函数替换另一个继承体系的虚函数 条款36：绝不重新定义继承而来的非虚函数 如果派生类重新定义了非虚成员函数，指向同一个对象的两个指针访问这个成员函数时会指向两个不同的对象，D对象表现出B或者D的行为，决定因素在于声明的类型 虚函数是动态绑定，两个调用都是指向D::mf(); 在任何情况下不应该在派生类中重新定义一个非虚成员函数 条款37：绝不重新定义继承而来的缺省参数值 虚函数是动态绑定，缺省参数是静态绑定，静态绑定是前期绑定，动态绑定是后期绑定 静态绑定下，函数不从基类继承缺省参数值， 对象的动态类型是指目前所指的对象的类型 动态类型可以在程序执行过程中更改，Shape* pc=new Circle; virtual是动态绑定来的，调用一个虚函数是，究竟调用哪一份函数实现代码，取决于发出调用的对象的动态类型 virtual是动态绑定，而缺省参数值是静态绑定，可能会出现基类和派生类各出一半力完成声明式，这种方法可以有效提高运行期效率 如果给基类和派生类函用户同时传缺省参数值，将会发生代码重复和相依性 如果基类的缺省参数值改变，派生类的这些缺省参数值也必须改变，否则就会导致重复定义继承而来的参数值 缺省的参数值是静态绑定，而虚函数要覆写的东西是动态绑定 条款38：通过复合塑模出有一个或者根据某物实现出 复合是类型之间的一种关系，某种类型的对象中包含其他类型的对象 复合还叫分层，内含，聚合，内嵌 当对象发生在应用域对象之间表现出has-a的关系，人、骑车、视频、画 当对象发生在实现域对象之间表现出根据某物实现出的关系，有缓冲区、互斥器、查找树 如果两个类之间并非is-a的关系，但是Set可以根据list对象实现出来，Set成员函数可以大量依靠list及标准程序库其他部分提供的机能来完成 条款39：明智而慎重的使用private继承 如果继承类型是private，编译器不会再自动将一个派生类对象转换为一个积累对象 私有继承的派生类成员都是private属性 使用D继承B，是要采用B内已经备妥的某些特性 private是一种实现技术，private意味着部分继承，接口被略去 在基类内声明一个嵌套式私有类，可以有效阻止派生类重新定义虚函数 可以将基类和派生类的编译依存性降至最低 私有继承主要用于一个派生类想要访问基类的保护成分，或者重新定义一个或多个虚函数，涉及空间最优化使用私有继承 私有继承只适合处理的类不带任何数据，没有非静态成员函数，没有虚函数，没有虚基类 空白基类最优化一般只有在单一继承下才可行 不是is-a关系的两个类，一个类需要访问另一个类的保护成员，或者需要重新定义一个或者多个虚函数，私有继承可能是正统设计策略 在考虑了其他方法，但是仍然认为私有继承是最佳方法就使用它 条款40：明智而慎重的使用多重继承 多重继承造成从一个以上的基类继承相同的名称，根据重载函数调用原则，两个函数有相同的匹配程度就会造成歧义，为了解决这个歧义，指明调用的哪一个是基类内的函数 多重继承是继承一个以上的基类，但是这些基类不在继承体系内有更高级的基类，否则如果造成钻石型多重继承，将会导致复制路径歧义 将造成歧义的两个基类成为虚基类，继承时采用虚继承 使用共有继承时，应该用虚公有继承，虚继承产生的对象体积较大，访问成员变量的速度也比较慢 如非必要不要使用虚继承，如果使用虚继承尽量避免在其中存放数据 抽象类无法被实体化创建对象，只能用累的指针和引用来编写程序 抽象类可以用工厂函数将派生类实体化 7. 模板和泛型编程条款41：了解隐式接口和编译期多态 显式接口在源码中明确可见，基类对象对基类的一些虚成员函数的调用表现出运行期多态 模板函数内，模板类型必须支持的函数和比较运算是模板类型的隐式接口 模板具现化发生在编译期，以不同的模板参数具现化会调用不同的函数，这就是编译期多态 显式接口由函数的签名式构成，隐式接口由有效表达式构成 模板的多态通过模板具现化和函数解析完成的，都在编译期完成，无法在模板中使用不支持模板要求的隐式接口的对象 条款42：了解typename的双重意义 template&lt;typename T&gt; class Widget;和template&lt;typename T&gt; class Widget;声明参数时typename和class完全一样 两个local变量，有从属名称和非从属名称 嵌套从属名称可能导致解析困难，必须确定声明确实是一个类型，typename C::const_iterator放置关键字typename告诉C++这是个类型 typename不可以出现在基类list内的嵌套从属类型名称之前，也不可以在成员初值列中作为基类修饰符 typename用于声明嵌套从属类型名称，用typedef设定名称代表，typedef typename并列合理 typename在不同的编译器上兼容性有问题，可能会在移植性上出现问题 条款43：学习处理模板化基类内的名称 模板参数在运行时确定，所以在编译期编译器无法调用基类的成员函数，因为无法辨别被调用函数的作用域 template&lt;&gt;表示这既不是模板也不是标准类 template&lt;&gt; class MsgSender&lt;CompanyZ&gt;模板全特化，一旦参数被定义为CompanyZ，再也没有其他模板参数可供变化 编辑器往往会拒绝在模板化基类内寻找继承来的名称 解决4的问题：1）在基类函数调用动作之前加上this-&gt;；2）加上using声明，将基类名称带入派生类作用域内；3)明白指出被调用的函数在基类的作用域内 5-3）如果被调用的是虚函数，这个操作会关闭virtual绑定行为 条款44：将与参数无关的代码抽离templates 模板生成多个类或多个函数，任何模板代码不该与某个造成膨胀的模板参数产生相依关系 费类型模板参数造成的代码膨胀可以用函数参数或者class成员变量替换 因类型参数造成的代码膨胀，可以通过完全相同的二进制表述的具现类型共享实现码 条款45：运行成员函数模板接受所有兼容类型 智能指针是行为像指针的对象，提供指针没有的机能 如果用两个base-devided关系的类型具现化某个模板，产生出来的两个具现体并不具有base-devided关系 模板和泛型编程 用函数模板来生成无数个拷贝构造函数来完成从一个类型生成另一个类型的智能指针的操作 没有声明explicit，允许原始指针类型之间的隐式转换 加入get函数筛查返回智能指针对象所持有的原始指针的副本，可以在构造模板实现代码中约束转换行为 只有存在隐式转换时可以通过编译 tr1::shared_ptr中允许shared_ptr隐式转换成另一个shared_ptr类型，但是从内置指针或者其他智能指针隐式转换不被认可，显式强制转换可以cast 使用成员函数模板生成可接受所有类型的函数 如果声明用于泛化copy函数或泛化复制操作，还需要声明正常的拷贝构造函数和拷贝赋值运算符 条款46：需要类型转换时请为模板定义非成员函数12Rational&lt;int&gt; oneHalf(1,2);//从int推断出实例化运算符的T是intRational&lt;int&gt; result=oneHalf*2;//模板实参在推导过程中不将隐式类型转换函数纳入考虑 要使用隐式转换函数，必须要先知道那个函数存在，为了知道这个必须先为相关的函数模板推导出参数类型，然后才能将适当的函数具现化出来 模板实参的推导过程中不考虑采纳通过构造函数发生的隐式类型转换 编译器总能在类模板具现化时得知T，因此将重载运算符函数声明为 friend const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs); 当oneHalf被声明为Rational，类模板被具现化出来，作为过程的一部分，friend函数的重载运算符*函数被自动声明出来 这个friend是非函数模板，编译器在调用它时可以使用隐式转换函数 这个函数被声明在类之内，没有被定义出来，无法连接定义在类外部的定义式 要在类内部完成所有实参的具现化，满足这一要求的类内部非成员函数，只有定义在类内部的友元函数 如果要调用外部的辅助函数，必须先将友元函数的声明放在前面 条款47：请使用traits class表现类型信息 工具性模板函数advance将某个迭代器移动给定的某个位置，但是只有随机访问的迭代器才能完成+=操作，其他的只能反复执行++或者– 如果要使用+=操作，必须要首先判断迭代器是否是随机访问迭代器，traits允许在编译器间取得某些类型信息 traits是一种技术，对内置类型和用户自定义类型表现的一样好，针对迭代器的被命名为iterator_traits 针对每一个类型IterT，在结构iterator_traits一定会定义某个typedef名为iterator_category，来确认IterT的迭代器分类 指针不能嵌套typedef，指针的行径和随机访问迭代器类似 利用重载完成编译器匹配，利用重载的doAdvance在编译期完成参数匹配，获得正确的参数类型，在advance函数体内调用doAdvance 条款48：认识模板元编程(Template metaprogramming) TMP可以实现将工作从运行期转移到编译期，使错误可以在编译期被发现，上一个条款中的traits就是TMP 上例中traits_base版本，对其他迭代器调用+=，如果迭代器不是随机访问迭代器会导致调用失败，而TMP在编译期完成能够保证代码的正确调用 TMP是函数式语言，TMP的循环借由递归完成 使用TMP可以达成很多目标，如：1）确保度量单位正确结合；2）优化矩阵运算；3）生成客户定制的设计模式 8. 定制new和delete C++内存管理例程主要是分配例程和归还例程 多线程环境下的内存管理需要适当的同步控制、有锁算法、防止并发访问等操作，否则会很容易导致堆的数据结构 operator new和operator delete只能用来分配单一对象 arrays用的内存用operator new[]和operator delete[]分配 堆内存是由容器所拥有的分配器对象管理，不是由new和delete直接管理的 条款49：了解new-handler的行为 如果operator new无法满足某一内存分配需求，会抛出异常，调用一个客户指定的错误处理函数，就是所谓的new-handler 1234567namespace std&#123;typedef void (*new_handler)(); //定义一个指针指向一个函数，不返回任何东西new_handler set_new_handler(new_handler p) throw(); /*set_new_handler获得一个new_handler并返回一个new_handler，throw()是一个异常明细，表示函数不抛出任何异常*//*参数是个指针，指向operator new无法分配足够内存时被调用的函数*//*返回值也是一个指针，指向set_new_handler被调用前正在执行的new-handler函数*/&#125; 2. 一个良好的new-handler函数必须做到以下事情 让更多内存可以被使用 安装另一个new-handler 卸除new-handler 抛出bad_alloc（或派生自bad_alloc）的异常 不返回，调用abort或exit 3. 可以为每一个class提供自己的set_new_handler和operator new，自定义的Widget的operator new做以下事情： 调用标准set_new_handler告知Widget的错误处理函数 调用global operator new执行实际的内存分配 如果global operator new能够分配足够一个Widget对象所用的内存，Widget的operator new返回一个指针指向分配所得 4. set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用 5. nothrow是一个局限性工具，只能保证operator new不抛出异常，但是构造过程中，构造函数仍然有可能会抛出异常 条款50：了解new和delete的合理替换时机1. 要替换编译器提供的operator new和operator delete的三个常见理由： 用来检测运行上的错误 强化效能 收集使用上的统计数据 增加分配和归还的速度 降低缺省内存管理器带来的空间额外开销 弥补缺省分配器中的非最佳齐位 将相关对象成簇集中 获得非传统行为 2. 许多计算机体系结构要求特定的类型必须放在特定的位置上，称为齐位 malloc在齐位要求下工作，operator new返回得自malloc的指针是安全的 如果没有获得适当齐位的指针，将会导致程序崩溃或者执行速度变慢 条款51：编写new和delete时需固守常规 实现一致性的operator new必须返回正确的值；内存不足时调用new-handing函数；必须有对应零内存需求的准备；避免不慎掩盖正常形式的new operator new不止一次的尝试分配内存，每次失败后都调用new-handling函数，假设这里的new-handling函数能够释放部分内存，只有new-handling函数的指针是null时，operator new才会抛出异常 operator delete删除null指针永远安全 如果基类没有虚析构函数，则派生类对象传给operator delete的size_t数值可能存在错误，如果检查大小发生错误则申请调用::operator delete 条款52：写了placement new也要写placement delete 构造对象并分配动态内存时，如果内存分配完之后，构造函数出错，要使用正确的delete释放内存，如果使用的是带有附加参数的new，系统无法辨别出正确的delete 如果operator new函数除了必须有的size_t还有其他参数，这个函数就是placement new 在运行期选择寻找参数和类型与placement new相同的placement delete释放内存，如果没有找到，则什么都不做 基于上一条，我们有必要声明一个和placement new参数和类型相同的placement delete placement delete只有在伴随placement new调用而出发，删除一个对象调用正常的operator delete 成员函数的名称会掩盖外围作用域的相同名称，同时要避免类专属的new掩盖客户期望的其他new 基于6，建立一个基类包含所有正常形式的new和delete，要用自定义形式扩充标准形式的客户，利用继承机制和using声明使基类内的new和delete可见 9. 杂项讨论条款54：熟悉包括TR1在内的标准程序库 Technical Reprot 1TR1叙述了14个新组建，全部存放在std命名空间内，嵌套命名空间在tr1内，如std::tr1::shared_ptr 智能指针 tr1::function，可以表示任何可调用物，如函数或函数对象，这是一个模板，以目标函数的签名为参数 tr1::bind，第二代绑定工具。做STL绑定器bind1st和bind2nd所做的每一件事，且可以和const和non-const成员函数协同运作，可以和引用参数协同运作，不需要写作就可以处理函数指针 hash tables，实现set，multiset，map和multi-map，名称是tr1::unordered_set等 正则表达式 tuples变量组，是标准库程序pair模板的新一代，tr1::tuple可以支持任意个数的对象 tr1::array，支持begin和end的数组，大小固定不适用动态内存 tr1::mem_fn，语句构造上与成员函数指针一致的东西，纳入并扩充了C++98的men_fun和mem_ref tr1::reference_wrapper，让引用的行为更像对象，可以造成容器像引用，但是容器只是持有对象和指针 随机数生成工具，超越rand 数学特殊函数，Languerre多项式、Bessel函数、完全椭圆积分等 C99兼容扩充 type traits，提供编译期信息 tr1::result_of，是一个模板，用来推导函数调用的返回类型 TR1是对程序标准库的纯粹添加，没有任何TR1组建用来替换，早期代码仍然适用]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 1]]></title>
    <url>%2F2019%2F04%2F22%2FEffective_C%2B%2B_1%2F</url>
    <content type="text"><![CDATA[Effective C++ 条款1-25构造函数 对用户自定义的对象而言，初始化由构造函数执行 default构造函数是一个可被调用而不带任何实参者 explicit用来阻止构造函数进行隐式类型转换，但是仍可以用来执行显式的类型转换 拷贝构造函数可以用来以同类型对象初始化自我对象，copy assignment操作符被用来从同一个类型对象中拷贝其值到自我对象 =也可以用来调用拷贝构造函数 1. 习惯C++条款1：View C++ as a federation of languages C++是一个多重泛型编程语言：1）过程形式；2）面向对象；3）函数；4）泛型；5）元编程 有四个次语言组成的联邦库，C、Object-Oriented C++、Template C++/STL 条款2：尽量以const/enum/inline替代#define 用编译器替代预处理器 用常量替换#define：1）定义常量指针const string authorName();；2）class专属常量：声明式static const int NumTurns=5;定义式const int GamePlayer::NumTurns;前面已经赋过初值了，所以不需要再赋初值 #define不能用来创建class专属常量，以及所有封装性的 常量用const对象或者enums替换#defines 形似于函数的宏，最好改用inline函数替换#defines 条款3：尽可能使用const const指定语义约束，const char* p; //p指向的数据是const&amp;char* const p; //常量指针 const Widget* pw; 和 Widget const pw; //含义相同 指针pw指向的数据是常量 声明迭代器const和声明指针const一样，迭代器不能指向不同的对象，但是对象的值可以改动。std::vector&lt;int&gt; vec; const std::vector&lt;int&gt;::iterator iter=vec.begin(); 声明迭代器指向的对象的值不可改变，使用const_iteratorstd::vector&lt;int&gt;::const_iterator iter=vec.begin(); const成员函数的作用：1）可以使class接口更容易被理解（哪个函数可以改动对象，哪个不能）；2）可以用来操作const对象 两个函数只是常量性不同，可以被重载 程序中的const对象大多用于引用传递或指针传递 bitwise constness不更改对象的任何成员变量，const成员函数不能更改对象内任何non_static成员变量，但是如果有指针指向对象，不能更改指针，但是可以更改指针的内容，这种情况会导出logical constness logical constness一个const成员函数可以更改对象内的某些bits，可以使用mutable释放掉non_static成员变量的bitwise constness 常量性转除：用non_const operator[]调用const兄弟，将*this转型为const类型用static_cast，并且将去除const operator[]返回值中的const用const_cast完成 条款4：确定对象在使用前已经被初始化 单用一次拷贝构造函数效率较高 如果成员是const或者是引用，必须被初始化，而不是赋值 编译单元是产生单一目标文件的源码，两个源码文件中的两个non_local static对象，其中一个的初始化可能用到另一个编译单元的未初始化对象 将每个non_local static对象搬到自己的函数中，该对象在这个函数中被定义为static，函数返回一个引用指向对象，本质上是non_local static对象被local static替换了 C++保证在函数调用期间，首次遇上local static对象的定义式被初始化 但是也在多线程系统中带有不确定性，在单线程启动阶段手动调用所有reference-returning函数，消除与初始化有关的”竞速形势“ 只要对对象有良好的初始化顺序就能有效防止reference-returning函数的初始化次序问题 手工初始化内置型non_member对象，使用成员初值列对付对象的所有成分，加强设计 2. 构造/析构/赋值运算条款5：了解C++默认编写并调用的函数 编译器生成的默认构造函数和析构函数是public和inline的，只有这些函数被调用的时候才会被编译器创建出来 编译器产生的析构函数不是虚函数，除非这个类的基类的析构函数是虚函数 默认拷贝构造函数只是将来源对象的每一个非静态成员变量拷贝到目标对象 如果有条件不符合，则编译器会拒绝生成默认赋值运算符 条款6：可以拒绝编译器自动生成的函数 可以将拷贝构造函数和赋值运算符声明为private的 条款7：为多态基类声明virtual析构函数 factory函数，返回指针指向派生类动态分配的对象，在完成之后delete 如果继承类对象需要由基类的析构函数完成删除，会出现为定义行为，对象的继承成分没有被销毁 给基类声明一个虚析构函数，可以消耗整个对象 虚函数的目的是允许继承类的实现可以客制化 只有当类中至少含有一个virtual函数时，才为他声明virtual析构函数 纯虚析构函数可能导致抽象类，不能被实体化，不能为这种类创建对象，定义纯虚析构函数virtual ~AWOV()=0;，必须为纯虚析构函数提供定义，最深层的派生类的析构函数首先被调用，然后沿着派生链往上 带多态性质的基类应该声明一个虚析构函数，反之就不使用虚析构函数 条款8：别让异常逃离析构函数 多个异常产生导致程序过早结束，或产生不明确的行为，剩下的对象没有释放将会导致内存泄露 创建一个资源管理类，在析构函数中调用close函数，通过调用abort制作转运记录，记录close调用失败 程序在发生异常时继续执行，使用try/catch记录close调用失败 重新设计资源管理类接口，使客户可以对出现的问题作出反应，检查链接是否关闭，可以调用析构函数关闭防止遗失数据库链接 析构函数不应该突出异常，对于客户需要对某个操作函数运行期间抛出的异常作出反应，在class中编写普通函数执行该操作 条款9：不在构造和析构过程中调用虚函数 构造派生类对象首先调用基类的构造函数，在构造过程中派生类的成员变量尚未初始化，在基类构造期间，对象是基类对象，虚函数会被解析成基类 要解决这种问题，将基类的虚函数改为非虚函数，利用private辅助函数创建一个值传给基类的构造函数，这个函数是static不会意外指向尚未完成初始化的成员变量 条款10：令operator=返回一个reference to *this 实现赋值连锁形式x=y=z=15;，返回操作符左侧对象 条款11：在operator=中处理自我赋值 自我赋值安全，证同测试，如果是自我赋值就不做任何事 异常安全，可能会返回一个指针指向被删除的bitmap，无法安全读取也无法安全删除 在赋值pb之前删除pb，如果newBitmap抛出异常，pb保持原状 使用copy and swap技术，Weight temp(rhs); swap(temp); 条款12：复制对象时不要忘记每一个成分 设计良好的面向对象系统会将对象的内部封装起来，只留两个函数负责对象拷贝，拷贝构造函数和拷贝赋值运算符 自定义的拷贝构造函数，编译器不会提醒出错，拷贝构造函数没有复制基类的成员变量，没有指定实参传递给基类构造函数，调用基类的默认构造函数。 派生类无法访问基类构造函数的private成分，必须用派生类的拷贝函数调用相应的基类函数 确保复制所有的local变量，调用所有的基类适当的拷贝函数 不要使用拷贝运算符函数调用拷贝构造函数，也不要用拷贝构造函数调用拷贝运算符函数，可以建立一个新的成员函数给两个函数调用，这种函数是private，可以消除两个函数之间的代码重复 3. 资源管理条款13：以对象管理资源 过早的return语句，函数因为continue、goto语句过早退出，或者函数抛出异常将会造成投资对象保存的资源内存泄露 将资源放进对象，析构函数会自动释放资源 资源被存放在堆中，当控制流离开那个区块或函数时被释放 智能指针的析构函数自动对其所指对象调用delete，避免潜在的资源泄露的可能性 auto_ptr&lt;Investment&gt; pInv(creatInvestment()); creatInvestment()返回的资源被当做智能指针的初值，赋值而不是初始化。控制流离开区块，对象被销毁，析构函数自动被调用 不能让多个auto_ptr同时指向同一个对象，否则对象会被删除一次以上，产生未定义行为 如果使用拷贝构造函数或者拷贝赋值运算符赋值auto_ptr会变成null 引用计数型智慧指针RCSP，持续追踪共有多少个对象指向某个资源，在无人指向它时，释放该资源，但是RSCP无法打破环状引用 tr1::shared_ptr，上述的两种智能指针在析构函数内做delete而不是delete[] 条款14：在资源管理类中小心copying行为 可以使用禁止复制，将copying操作声明为private 使用引用计数，关于互斥器解除锁定，引用计数为0时，以unlock为删除器，进行互斥器解锁，lock类不声明析构函数，当因此计数为0时自动调用系统自动生成的析构函数 复制资源管理对象时，复制其所包覆的资源，进行的是深度拷贝 转移底部资源的拥有权，确保只有RAII对象指向一个未加工的资源，资源的拥有权会从被复制物转移到目标物 条款15：在资源管理类中提供对原始资源的访问 shared_ptr和auto_ptr都提供get成员函数，用来执行显式转换，返回智能指针内部的原始指针的复件 指针取值操作符operator-&gt;和operator*，允许隐式转换至底部原始指针 显式转换比较安全，隐式转换对客户比较方便 条款16：承兑使用new和delete时采取相同形式 调用new，内存会被分配出来，调用构造函数 调用delete，首先调用析构函数，然后释放内存 最好不要对数组形式做typedef动作 条款17：以独立语句将newed对象置入智能指针 processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget),priority());执行new Widget要在tr1::shared_ptr执行之前执行，因为这个结果要被传给tr1::shared_ptr作为实参 如果在上述两个操作中间执行priority，调用失败会造成new Widget返回的指针遗失，在processWidget的调用过程中引发资源泄露 使用分离语句先将new Widget单独传递给一个智能指针，然后将这个智能指针传递给processWidget 4. 设计与声明条款18：让接口更容易被正确使用，不易被误用 限制值得合理范围，使用安全类型，以函数替换对象，以const修饰operator*的返回类型 促进正确使用的办法包括接口的一致性，以及内置类型的行为兼容 阻止误用的办法建立新类型，限制类型上的操作，束缚对象值，消除用户的资源管理责任 定制删除器，防止动态连接程序库问题，用来自动解除互斥锁 条款19：设计class犹如设计type 新type对象如何被创建和销毁 对象初始化和对象赋值有什么区别，这决定了构造函数和赋值运算符的差别，初始化和赋值对应于不同的函数调用 拷贝构造函数用来定义一个类型的值传递是如何实现的 对class的成员变量而言，通常只有某些数值集是有效的 派生类的类型收到基类的设计的束缚 是否需要类型转换操作符或者可被单一实参调用的构造函数 什么样的操作符和函数对新type是合理的，什么标准函数应该被驳回，谁该采用新type成员（决定成员的public/protected/private，决定类或者函数是友元，以及嵌套的合理性）条款23、24、46 未声明接口，条款29，对效率、异常安全性以及资源运用提供何种保证 在某些情况下定义一个或多个非成员函数或者模板就能得到想要的机能 条款20：用引用常量代替值传递 值传递以实际实参的副本为初值，调用端返回的是函数返回值的一个复件，这些副本由对象的拷贝构造函数产出，费时 用常量引用传递参数，const Student&amp; s函数不会改变传入的对象的初值 值传递时，基类构造函数会分割对象的派生类部分和基类部分，可能会使派生类对象编程基类对象。使用引用常量传递参数，参数类型由传进来的参数决定，不会被改变 使用内置类型时值传递效率更高，但是并不意味着复制内置类型更快，诸如此类 用户自定义类型的大小容易发生变化，内置类型、STL的迭代器和函数对象使用值传递效率较高 条款21：必须返回对象时不要返回引用 返回对象的引用时这个对象必须已经存在 为了避免调用构造函数，函数返回的可能是local对象，在函数返回前就已经被销毁了 在堆内构造一个对象并返回reference指向它，调用了构造函数，又不能准确的delete引用背后隐藏的指针，造成内存泄露 定义在函数内部的static对象，造成多线程安全 Rational(lhs.n*rhs.n, lhs.d*rhs.d)构造成本和析构成本没有省略，但是保证正确 条款22：将成员变量声明为private 使用函数访问成员变量可以用某个计算替换这个成员变量 将成员变量隐藏在函数接口后面为所有可能的实现提供弹性 封装成员变量，确保class的约束条件总是被维护，只有成员函数可以影响他们 public意味着不封装，不封装意味着不可改变 protected成员变量和public成员变量一样缺 少封装性，在这种情况下如果成员变量被改变将会造成大量代码被破坏 条款23：以非成员、非友元函数替换成员函数 面向对象的守则是尽可能的封装，非成员函数的封装性较高 非成员函数允许对类相关性能有较大的包裹弹性，最终导致较低的编译相依度，增加类的可延伸性 封装性越高，我们越能自由的改变对象数据，我们使用非成员、非友元函数替换成员函数，不会增加访问私有成员变量的函数数量，不会降低封装性，非成员非友元函数可以是另一个类的静态成员函数 让这个非成员函数放在class的同一个命名空间中 将不同的相关便利函数声明在不同的头文件中但隶属同一个命名空间，允许客户只对他们所用的那一部分形成编译相依，客户可以扩展这一组遍历函数，可以将非成员非友元函数添加到这个头文件里 可以增加封装性、包裹弹性、机能扩充性 条款24：如果所有参数都需要类型转换，为此采用非成员函数 例如建立一个数值类型的类，有一个重载乘法运算符作为成员函数，类类型和整型变量混合运算时，不能使用交换率，因为没有满足这样参数组合的成员函数或是在同一个作用域下的非成员函数 只有参数位于参数列时隐式类型转换才是合法的 将重载乘法运算符称为一个非成员函数：const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs); 条款25：写一个不抛出异常的swap函数12345678namespace std&#123; template&lt;typename T&gt; void swap(T&amp; a, T&amp; b)&#123; T temp(a); a=b; b=temp; &#125;&#125; 只要T支持拷贝操作，缺省的swap代码会置换类型为T的对象 swap缺省行为导致变慢 template&lt;&gt; void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b);template&lt;&gt;全特化的std::swap版本施行于Widget身上 通常我们不允许改变std命名空间内的任何东西，但是可以为标准模板制造特化版本，使它专属于我们的类 令类声明一个swap的public成员函数，然后将std::swap特化调用成员函数 C++只允许对类模板偏特化 客户可以全特化std内的模板，但是不能添加新的模板到std里 我们可以定义一个非成员swap函数来调用swap成员函数 如果T是Widget并且位于命名空间WidgetStuff，编译器采用使用查找原则找到专属的swap，如果类的std::swap已经被特化，特化版会被挑中，如果没有则调用std::swap public swap成员函数不能抛出任何异常]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序间交互和通信]]></title>
    <url>%2F2019%2F04%2F20%2F%E7%A8%8B%E5%BA%8F%E9%97%B4%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[程序间交互和通信系统级I/O文件 普通文件：文本文件和二进制文件 目录包含一组链接的文件，每个链接都将文件映射到另一个文件。每个目录至少包含两个条目：’.’表示目录本身的链接和’..’表示父目录的链接 套接字是用来与另一个进程的进行跨网通信的文件 其他文件类型还包括命名通道、符号链接以及字符和块设备 打开和关闭文件 open函数打开文件或者创建一个新文件，open将filename转换为一个文件描述符，并且返回文件描述符fd=Open(&quot;foo.tst&quot;,O_RDONLY,0);以只读的方式打开一个已存在的文件 flag参数可以是一个或多个位的掩码的或，为写提供一些额外的指示 O_CREAT表示如果文件不存在，就创建它的一个截断的空文件；O_TRUNC表示如果文件已经存在，就截断它；O_APPEND表示每次写操作前，设置文件位置到文件结尾处fd=Open(&quot;foo.tst&quot;,O_WRONLY|O_APPEND,0) mode参数设置新文件的访问权限位 进程使用close关闭文件 读和写程序 程序通过read和write函数执行输入和输出 1234567891011#include &lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t n);//read函数从描述符为fd的当前文件复制最多n个字节到内存位置buf//若成功则返回读的字节数，若EOF返回0，若失败返回-1ssize_t write(int fd,const void *buf,size_t n);//write函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置//成功返回写的字节数，失败返回-1//read和write传送的字节比应用程序要求的少，不足值不代表错误//如果打开的文件应用于网络套接字，内存缓冲约束和较长的网络延迟会引起read和write返回不足值 通过调用lseek函数能够修改当前文件的位置 用RIO包读写（Robust I/O） 无缓冲的输入输出函数，直接在内存和文件之间读写文件 带缓冲的输入输出函数，缓存在应用级的缓冲区内 无缓冲的输入输出函数123456#include &lt;&quot;csapp.h&quot;&gt;ssize_t rio_readn(int fd,void *usrbuf,size_t n);//从描述符为fd的当前文件复制最多n个字节到内存位置usrbufssize_t rio_writen(int fd,void *usrbuf,size_t n);//从内存位置usrbuf复制至多n个字节到描述符fd//只有遇到EOF时才会返回不足值，对同一个描述符可以任意交错调用rio_readn和rio_writen的代码 5.带缓冲的输入输出函数，调用包装函数，从内部缓冲区复制一个文本行，当缓冲区变空时，自动调用read填满12345678910#include &lt;&quot;csapp.h&quot;&gt;void rio_readinitb(rio_t *rp,int fd);ssize_t rio_readlineb(rio_t fd,void *usrbuf,size_t maxlen);//每打开一个描述符，都会调用一次rio_readinitb函数，将描述符fd和地址rp处的读缓冲区联系起来//rio_readinitb函数从文件rp中读出下一个文本行（包括结尾的换行符），将它复制到内存为止，usrbuf用NULL结束这个文本行//rio_readinitb函数最多读maxlen-1个字节，余下的一个字节留给NULL，超过的字符被截断ssize_t rio_readnb(rio_t fd,void *usrbuf,size_t n);//rio_readnb函数从文件rp中最多读n个字节到内存位置usrbuf//对同一个描述符，可以任意交叉调用rio_readinitb和rio_readnb 读取文件元数据 程序调用stat和fstat函数，检索到关于文件的信息（文件元数据）1234567#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int stat(const char *filename,struct stat *buf);//以文件名作为输入，填写stat数据结构中的各个成员，Web服务器需要stat数据结构中的st_mode和st_size成员int fstat(int fd,struct stat *buf);//以文件描述符作为输入 读取目录内容123456789101112131415161718192021//程序用readdir系列函数来读取目录的内容#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name);//以路径名为参数，返回指向目录流的指针（目录项列表），出错则返回NULL#include &lt;dirent.h&gt;struct dirent *readdir(DIR *dirp);//每次对readdir的调用的返回都指向流dirp中下一个目录项的指针，如果失败返回NULL并设置errno//每个目录的结构struct dirent&#123; ino_t d_ino;//文件位置 char d_name[256];//文件名&#125;;#include &lt;dirent.h&gt;int closedir(DIR *dirp);//关闭流并释放所有资源 共享文件 内核用三个相关的数据结构表示打开的文件： 描述符表：表项由进程打开的文件描述符索引的，，每个打开的描述符表项指向文件表中的一个表项 文件表：所有进程共享表示打开文件集合的文件表，每个文件表项组成包括当前文件位置、引用计数、以及指向v-node表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数，内核不会删除这个文件表表项，直到引用计数为0 v-node表：所有进程共享，每个表项包含stat结构的大多数信息 多个描述符通过不同的文件表表项引用同一个文件，如以同一个filename调用open两次文件共享子进程继承父进程的打开文件 I/O重定向 Linux shell提供了I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来ls &gt;foo.txt #将标准输出重定向到磁盘文件 I/O重定向通过dup2工作123#include &lt;unistd.h&gt;int dup2(int oldfd,int newfd);//复制描述符表表项oldfd到描述符表表项newfd，覆盖newfd表项以前的内容，如果newfd已经打开了，则在oldfd复制之前关闭newfd 标准I/O 库libc提供了fopen、fclose、fread、fwrite、fgets、fputs、scanf和printf 将打开的文件模型化为一个流，类型为FILE的刘是对文件描述符和流缓冲区的抽象 选择合适的I/O 首选标准I/O 不要使用scanf和rio_readlineb来读二进制文件 对网络套接字的I/O使用RIO函数 标准I/O是全双工的，程序能够在同一个流上执行输入和输出 限制一：如果中间没有插入fflush、fseek、fsetpos和rewind的调用，输入函数不能跟在输出函数之后，fflush清空与流相关的缓冲区，后三个函数使用lseek函数重置当前文件位置。在每个输入操作前刷新缓冲区 限制二：如果中间没有插入fseek、fsetpos和rewind函数的调用，输出函数不能跟随在输入函数之后。对网络套接字使用lseek是非法的，对同一个打开的套接字打开两个流，一个用来写一个用来读 在网络套接字上不适用标准I/O，要使用RIO函数 网络编程 客户端和服务器运行在不同的主机上，通过计算机网络的硬件和软件资源来通信 网络是一种I/O设备，是数据源也是数据接收方，网络的物理接口，从网络上接收到的数据从适配器经过I/O和内存总线复制到内存，通过DMA传送，类似的数据也能从内存复制到网络 物理网络最底层LAN，最流行的局域网技术是以太网，集线器不加分辨的将从一个口收到的东西复制到其他每个口，每台主机都能看到每个位，每个以太网适配器都要有唯一的48位地址，存储在适配器的非易失性存储器上 主机可以发送帧到这个网段内的其他任何主机，每个帧都包含固定数量的头部，用来标识此帧的源和目的，此后紧跟的是数据位的有效载荷，每个主机适配器都可以看到这个帧，但是只有目的主机可以实际读取他 使用电缆和网桥可以将多个以太网段连接成较大的局域网，称为桥接局域网，网桥有选择地将帧从一个端口复制到另一个端口 多个不兼容的局域网可以通过路由器的特殊计算连接起来，组成互联网络 路由器连接到高速点到点电话连接，称为WAN广域网 用运行在每台主机和路由器上的软件协议，消除不同网络之间的差异，协议的两种基本能力： 命名机制，用一致的主机地址格式消除不兼容的局域网技术带来的差异，每台主机至少被分配一个互联网络地址，唯一的标识主机 传送机制，互联网协议定义一种将数据位捆扎成包（不连续的片）的统一方式消除差异。 包由包头和有效载荷组成，包头包含源主机和目的主机的地址，有效载荷包括从源主机发出的数据位 主机A传送数据到主机B的8个步骤如图所示 IP地址 IP地址就是32位无符号整数（IPv4） IP地址结构 123struct in_addr&#123; uint32_t s_addr;&#125;; TCP/IP为任意整数数据项定义了统一的网络字节顺序（大端字节顺序），Unix使用函数在网络和主机字节顺序间实时转换 IP地址通常是点分十进制表示的，128.2.194.242就是地址0x8002c2f2。Linux系统中可以用一下命令来确定主机的点分十进制地址hostname -i 并发编程 应用程序并发在以下几种情况是很有用的：访问慢速I/O设备、与人交互、通过推迟工作降低延迟、服务多个网络客户端、在多核机器上进行并行运算 三种基本构造并发程序的方法：进程、I/O多路复用、线程 基于进程的并发编程 在父进程接受客户端的连接请求，然后创建一个新的子进程来为每个新客户端提供服务 服务器监听一个监听描述符上的连接请求，然后假设服务器接受了客户端1的连接请求，并返回一个已连接描述符。在接受连接请求后，服务器派生子进程 这个子进程获得服务器描述表的完整副本，子进程关闭它的副本中的监听描述符3，父进程关闭已连接描述符4的副本，否则会引起内存泄露 包括SIGCHLD处理程序，回收僵死程序，当SIGCHLD处理程序执行时，SIGCHLD信号的阻塞的 父进程必须关闭它们各自的connfd副本 套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭了，到客户端的连接才会终止 进程并发的劣势： 父进程和子进程共享状态信息，进程有一个清晰的模型，共享文件表，但是不共享用户地址空间 独立的地址空间使得进程共享状态信息变得困难，必须使用显式的IPC（进程间通信）机制进行共享信息 进程控制和IPC开销很高，运行很慢，套接字接口是IPC的一种重要形式，允许不同的主机上的进程交换任意的字节流，包括管道、先进先出、系统V共享内存以及系统V信号量 基于I/O多路复用的并发编程 服务器响应两个相互独立的I/O时间：1）网络客户端发起连接请求；2）用户在键盘键入命令行 使用select函数，要求挂起进程，只有在一个或多个I/O时间发生后，才将控制返回给程序 12345678910111213//等待一组描述符准备好读#include &lt;sys/select.h&gt;int select(int n, fd_set *fdset, NULL, NULL, NULL); FD_ZERO(fd_set *fdset);//创建于一个空的读集合FD_CLR(int fd, fd_set *fdset);//FD_SET(int fd, fd_set *fdset);//定义读集合FD_ISSET(int fd, fd_set *fdset);//确定哪个描述符准备好读了//fd_set集合是描述符集合/*允许对描述符做三件事，分配它们，将此种类型的变量赋值给另一个变量，用FD_ZERO、FD_CLR、FD_SET和FD_ISSET宏来修改它们*//*select函数会一直阻塞，直到读集合中至少有一个描述符准备好可以读。从该描述符读取一个字节不会阻塞*//*函数修改参数fdset，返回值指明准备好集合的技术，每次调用select函数都会更新读集合*/ 一旦连接到某个客户端，就会连续回送输入行，直到客户端关闭连接中的一端 I/O复用的优势和劣势 优点：有更多的对程序行为的控制；运行在单一进程的上下文中，每个逻辑控制流都能访问该进程的全部地址空间；共享进程容易，可以用熟悉的调试工具调试并发服务器 事件驱动的缺点：编码复杂，代码比基于进程的服务器多3被；并发粒度减小，复杂性上升；在故意只发送部分文本然后停止的恶意客户端攻击前很脆弱；不能充分利用多核处理器 粒度是每个逻辑流每个事件片执行的指令数量 基于线程的并发编程 线程是运行在进程上下文中的逻辑流，线程由内核自动调度 每个线程都有自己的线程上下文，包括线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码 所有运行在一个进程中的线程共享该进程的整个虚拟空间 线程执行模型 每个进程开始都是单一线程，这个线程称为主线程 主线程创建一个对等线程，从这个时间点开始，两个进程并发地运行 主线程执行一个满系统调用，或者被系统的间隔计时器中断，控制会通过上下文切换传递到对等线程 线程的上下文比进程的上下文小很多，线程的上下文切换比进程的上下文切换快的多 主线程总是第一个运行的线程 和一个进程相关的进程组成一个对等线程池，独立于线程产生的线程 一个线程可以kill它的任何对等线程，或者等待它的任意对等线程终止 每个对等线程都能读写相同的共享数据 Posix线程 Posix线程是C程序中处理线程的一个标准接口，定义了约60个函数，允许程序创建、杀死和回收线程，与对等线程安全的共享数据，通知对等线程系统状态的变化1234567891011121314151617181920#include &quot;csapp.h&quot;void *thread(void *vargp);/*线程的本地代码被封装在一个线程例程中，每个线程例程都以一个通用指针作为输入，并返回一个通用指针*//*如果要传递多个参数给线程，将多个参数放在一个结构中，传递一个指向该结构的指针*/int main()&#123; pthread_t tid; /*tid存放对等线程的ID*/ Pthread_create(&amp;tid, NULL, thread. NULL); /*创建一个新的对等线程，主线程和新创建的对等线程同时运行，并且tid包含新线程的ID*/ Pthread_join(tid, NULL); /*主线程等待对等线程终止*/ exit(0); /*终止运行在这个进程中的所有线程*/&#125;void *thread(void *vargp) /*定义对等线程*/&#123; printf(&quot;hello,world!\n&quot;); return NULL;&#125; 创建线程 线程通过调用pthread_create来创建其他线程12345678#include &lt;pthread.h&gt;typedef void *(func)(void *);int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg);/*输入变量arg，在新线程上下文中运行线程例程f*，能用attr参数来改变新创建线程的默认属性，tid包含线程ID/#include &lt;pthread.h&gt;pthread_t pthread_self(void); /*新线程调用pthread_self函数来获得自己的线程ID*/ 终止线程 顶层的线程例程返回时，线程隐性终止 调用pthread_exit函数，线程会显式的终止，等待所有其他对等线程终止，再终止主线程和整个进程，返回值为thread_return 某个线程调用Linux的exit函数，函数终止该进程以及与该进程相关的线程 另一个对等线程通过当前进程ID作为参数调用pthread_cancel函数来终止当前线程 1234#include &lt;pthread.h&gt;void pthread_exit(void *thread_return);void pthread_cancel(pthread_t tid); 123456//回收已终止线程的资源#include &lt;pthread.h&gt;int pthread_join(pthread_t tid, void **thread_return);/*函数会阻塞，直到线程tid终止，将线程例程返回的通用void*指针赋值为thread_return指向的位置*//*然后回收已终止线程占用的所有内存资源*//*pthread_join只能等待一个指定的线程终止*/ 分离线程 在任何一个时间点上线程是可结合的或者是分离的 可结合的线程能够被其他线程收回或杀死，在被其他线程回收前，它的内存资源不释放 分离的线程不能被其他线程回收或者杀死，内存资源在终止时被释放 默认情况下，线程被创建成可结合的12345#include &lt;pthread.h&gt;int pthread_detach(pthread_t tid);/*分离可结合线程tid*//*web浏览器的连接请求都创建一个新的对等线程，不需要显式的等待每个线程的终止*//*每个对等线程都应该在开始处理请求之前分离它自身，就能在终止后回收它的内存资源*/ 初始化线程 pthread_once函数允许初始化线程例程相关的状态12345#include &lt;pthread.h&gt;pthread_once once_control=PITHREAD_ONCE_INIT;int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));/*once_control是一个全局变量或者静态变量，总是被初始化为PITHREAD_ONCE_INIT*//*第一次用参数once_control调用pthread_once时，调用init_routine*/ 基于线程的并发服务器 主进程不断等待连接请求，创建一个对等线程处理该请求 将已连接描述符传递给对等线程，传递这个描述符的指针，但是这种对等线程的赋值语句和主线程的语句之间引入了竞争，将accept返回的每个已连接描述符分配到自己的动态分配内存块 为了避免内存泄露，必须分离每个线程，使得他终止时的每个内存资源能被收回 线性内存模型 一组并发线程运行在进程的上下文中，每个线程都有自己的上下文 每个线程和其他线程共享进程上下文的剩余部分，包括用户虚拟内存空间，是由只读文本、读写数据、堆以及所有共享库代码和数据区域组成的。线程也共享相同的打开文件合集 将变量映射到内存 全局变量：虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用 本地自动变量：是定义在函数内部，但是没有static属性的变量，在运行时，每个线程的栈都包含它自己所有自动变量的实例 本地静态变量：是定义在函数内部并且有static属性的变量，虚拟内存的读/写区域只包含每个静态变量的一个实例6.共享变量，变量的一个实例被多个线程引用 用信号量同步线程 共享变量引入同步错误 两个对等线程在单处理器上同步运行，导致循环中的步骤错乱 进度图 进度图将指令模型化为一种状态到另一种状态的转换，转换被表示为有向线段 两条指令不能同时完成，不允许对角转换，不允许反向执行，不能向下或者向左 线程的临界区不允许和其他进程的临界区交替执行 保证每个线程在执行临界区时，有对共享内存变量的互斥访问 两个交界区形成的状态空间区域成为不安全区 绕开不安全区域的轨迹线叫做安全轨迹线 信号量 信号量s是具有非负整数值的全局变量，只能由两种特殊的操作来处理P和V P(s):如果s非0，s-1，如果s为零，挂起这个线程，直到s为非0 V(s):s+1，如果有操作阻塞在P等待s变成非0，V操作会重启线程中的一个，然后P将s-1 P和V保证正确初始化的信号量不会有一个负值，这个属性称为信号量不变性 123456789101112//POSIX标准定义了许多操作信号量的函数#include &lt;semaphore.h&gt;int sem_init(sem_t *sem, 0, unsigned int value); /*将信号量sem初始化为value*/int sem_wait(sem_t *s); //执行P操作int sem_post(sem_t *s); //执行V操作//等价的P和V的包装函数#include &quot;csapp.h&quot;void P(sem_t *s);void V(sem_t *s); 使用信号量来实现互斥 用P(s)和V(s)将临界区包围起来，使用这种二元信号量来保护共享变量的信号量 提供互斥为目的的二元信号量通常也称信号锁，P是互斥锁加锁，V是互斥锁解锁 一个被用作一组可用资源计数的信号量被称为是计数信号量 使用s&lt;0的状态建立一个禁止区，保证了临界区的互斥访问 利用信号量来调度共享资源 1234567891011121314151617181920typrdef struct&#123; int *buf; int n; int front; /*索引值，记录数组的第一项*/ int rear; /*索引值，记录数组的最后一项*/ sem_t mutex; /*提供互斥的缓冲区访问*/ sem_t slots; /*记录空槽位数量*/ sem_t items; /*记录可用项目的数量*/&#125;sbuf_t;/*sbuf_init函数为缓冲区分配内存，初始化所有变量*/void sbuf_init(sbuf_t *sp, int n)&#123; sp-&gt;buf=Calloc(n,sizeof(int)); sp-&gt;n; sp-&gt;front=sp-&gt;rear=0; Sem_init(&amp;sp-&gt;mutex,0,1); Sem_init(&amp;sp-&gt;slots,0,n); Sem_init(&amp;sp-&gt;items,0,0);&#125; 读者-写者问题读者优先，如果不是使用权限赋给写，读操作不需要等待；写优先，在写者后面到达的读者必须等待 使用线程提高并行性 将序列分配成t个不想交的区域，然后给t个不同的线程分配区域 为了避免多核之间全局变量同步和PV操作造成的大延迟，在每个线程中使用私有变量/局部变量计算局部和，这个私有变量不和其他线程共享，不需要互斥锁来保护更新，也不需要每次循环都同步全局变量 并行程序加速比：Sp=T1/Tp 相关测量量-效率：Ep=Sp/p=T1/pTp，具有高效率的程序比低效率的程序在有用的工作上花费更多的时间 弱扩展：在增加处理器数量的同时，增加问题的规模 线程安全 线程安全被多个并发线程反复强调，一直产生安全的结果，否则这个函数就是线程不安全的 第1类：不保护共享变量的函数 第2类：保持跨越多个调用的状态的函数：单线程中使用另一个函数设置种子，多线程中不再使用任何static数据，重写函数编程可重入函数 第3类：指向静态变量的指针的函数：重写函数或者使用加锁-复制技术，定义线程安全的包装函数，通过调用包装函数来避免线程不安全函数的调用 调用线程不安全的函数：第2类只能重写函数编程可重入函数，第1、3类同第3种使用带有互斥锁的包装函数 可重入函数，一个重要的线程安全的函数，在被多个线程共享时，不会引用任何共享数据，是线程安全函数的一部分 没有同步操作，比不可重入函数更高效一点 只有值传递的函数是显式的可重入函数 值传递和引用传递的函数是隐式可重入函数 竞争 程序的正确性依赖于一个线程要在另一个线程到达y点之前到达x点，会引发竞争 为示例程序中的每个整数ID分配一个独立的块，并传递给线程例程必须释放这些块以避免内存泄露 死锁 一组线程被阻塞了 两个禁止区重叠部分的左下方，会导致死锁 程序员使用P和V操作顺序不当，所有阻塞的线程都在等待一个不会发生的V 死锁是不可预测的 使用二元信号量来实现互斥时，可以用互斥锁加锁顺序原则来避免死锁。给定所有互斥操作一个全序，如果每个线程都以一种顺序获得互斥锁并以相反的顺序释放，这种操作是无思索的]]></content>
      <categories>
        <category>程序间交互和通信</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intel Core i7/Linux内存系统]]></title>
    <url>%2F2019%2F04%2F12%2FLinux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Intel Core i7/Linux内存系统 处理器封装包括4个核、一个所有核共享的L3高速缓存，DDR3内存控制器 每个核包含一个层次结构的TLB、一个层次结构的数据和指令高速缓存、一组快速的点到点链路 TLB是虚拟寻址的四条组相联的，L1、L2、L3是物理寻址的，块大小是64字节 L1和L2是8路组相联的，L3是16路组相联的 Core i7地址翻译第一级、第二级或第三级页表中条目的格式第四级页表中条目的格式 采用四级页表层次 每个进程都有自己私有的页表层次结构，CR3控制寄存器指向第一级页表的起始位置，CR3的值是每个进程上下文的一部分 第一级、第二级或第三级页表中条目的格式，P=1时，地址字段包含一个40位物理页号PPN，指向页表的开始处，要求物理页4KB对齐 第四级页表中条目的格式，P=1时，地址字段包括一个40位的PPN，指向物理内存中某一页的基地址，要求物理页4KB对齐 PTE有3个权限位，控制对页的访问 R/W确定页的读写权限 U/S确定能否在用户模式中访问 XD用来禁止从某些内存页取指令 每次访问一个页时，MMU都会设置A位，称为引用位；设置D位修改位，修改位告诉内核在复制替换页之前，是否要写会牺牲页。内核可以调用一条特殊的内核指令清除引用位和修改位 Linux虚拟内存系统Linux虚拟内存 Linux为每个进程维护了一个单独的虚拟地址空间，虚拟内存位于用户栈之上 内核虚拟内存包含内核中的代码和数据结构，Linux将一组连续的虚拟内存映射到相应的物理内存，内核的其他区域包含每个进程都不相同的数据 Linux将虚拟内存组织成一些区域的集合（段集合），允许虚拟地址空间有间隙 Linux组织的虚拟内存的结构 任务结构中的条目mm指向mm_struct，描述虚拟内存的当前状态 pgd指向第一级页表的基址；mmap指向一个vm_area_structs(区域结构)的链表 每个vm_area_structs都描述了当前虚拟空间的一个区域 内核运行进程时，将pgd存放在CR3控制寄存器中 具体区域的具体字段包含下面的字段：1）vm_start指向区域的起始处；2）vm_end指向区域的结束处；3）vm_port区域中所有页的读写许可权限；4）vm_flags描述区域内的页面是进程共享的还是私有的；4）vm_next指向链表中的下一个区域结构 Linux异常缺页处理： 检查虚拟地址A是否合法 检查内存访问是否合法 前两项都是合法的，内核选择一个牺牲页面，如果牺牲页面已经被修改过了，将它交换出去，换入新的页面并更新页表。缺页程序返回时，CPU重新执行这条指令，不会再发生缺页中断了 虚拟内存区域可以映射两种类型的对象中的一种： Linux文件系统中的普通文件 匿名文件：匿名文件是由内核创建的，如果CPU第一次引用这样一个区域内的虚拟文件时，内核就在物理内存中找到一个合适的牺牲页表，如果牺牲页面已经被修改过了，用二进制零覆盖并更新页表 共享对象 进程对共享对象的修改对其他进程是可见的；进程对私有对象的修改对其他进程不可见。 映射到共享对象的虚拟内存区域称为共享区域，类似的，有私有区域 两个进程将一个私有对象映射到它们虚拟内存的不同区域，，共享同一个物理副本，私有区域的页表条目被标记为只读，区域结构被标记为私有的写时复制。 如果有进程试图写私有页面，会触发一个保护故障，故障处理程序在物理内存中创建这个页面的一个新的副本，更新页表条目指向这个新的副本，然后恢复这个页面的写权限 fork函数为每个进程都保持了私有空间的抽象概念 execve函数,加载和执行程序 删除已存在的用户区域 映射色号私有区域 映射共享区域 设置程序计数器，指向代码区域的入口点 使用mmap函数的用户级内存映射 Linux进程可以用mmap函数来创建新的虚拟内存区域，并把对象映射到这些区域中 123456789101112131415161718#include &lt;首次适配会在链表起始处留下小的碎片&gt;#include &lt;sys/mman.h&gt;void *mmap(void *start , size_t length , int port , int flags , int fd , off_t offset);//新建虚拟内存区域地址从start开始，将文件描述符fd指定的对象的第一个连续的片映射到这个新的区域//连续的片的大小为length字节，从距文件开始处偏移量为offset字节的地方开始//start的地址通常被定义为NULL//参数prot包含描述新映射的虚拟内存区域的访问权限位...//参数flag描述被映射对象类型的位组成bufp=Mmap(NULL,size,PROT_READ,MAP_PRIVATE|MAP_ANON,0,0);//内核创建一个包含size字节的只读/私有/请求二进制零的虚拟内存区域//munmap函数删除虚拟内存的区域#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;int munmap(void *start,size_t length); 动态内存分配 动态内存分配器维护着一个进程的虚拟内存区域，成为堆heap 对于每个进程，内核维护着一个变量brk（break）指向堆的顶部 显式分配器：要求显式地释放任何已分配的块（new/delete） 显式分配器的约束：处理任意请求序列，但是没有假设分配和释放的顺序；立即响应请求；只使用堆；对齐块；不修改已经分配的块 隐式分配器：要求分配器检测一个已分配块何时不再被使用，释放这个块，也称为垃圾收集器。自动释放已分配的块的过程称为垃圾收集（智能指针） 垃圾收集器是一种动态内存分配器，自动释放程序不再需要的已分配块，自动回收堆存储的过程称为垃圾收集 有向可达图，将节点分为根节点和堆节点，对接点对应已分配的块，根节点不在堆中，指向堆中的指针 存在根节点到达块的路径，节点p可达，不可达节点对应于垃圾，不能被应用再次使用 收集器代替应用调用free Mark&amp;Sweep垃圾收集器 由标记阶段和清除阶段组成，标记阶段调用mark函数，清除阶段调用sweep函数一次。 标记阶段标记处根节点所有的可达和已分配的后继，清除阶段清除所有未标记的已分配块，块头部中空闲的低位中的一位通常用来表示这个块是否被标记了 ptr定义为typedef void *ptr123456789101112#include &lt;stdlib.h&gt;void *malloc(size_t size);//返回一个指针指向大小至少位size字节的内存块//如果程序要求的块比可用的虚拟内存大，返回NULL，设置errno//malloc不初始化它返回的内存，需要初始化的动态内存的程序可以适应calloc，想要改变已分配的块的大小使用realloc//malloc使用mmap和munmap显式地分配和释放堆内存#include &lt;unistd.h&gt;void *sbrk(inrptr_t incr);//通过brk指针增加incr来扩展和收缩堆//成功返回brk的旧值，失败返回-1，并将errno设为ENOMEN//如果incr为0，函数返回brk当前值 free 简单的返回到调用函数 1234#include &lt;stdlib.h&gt;void free(void *ptr);//ptr参数指向已分配块的起始位置，否则free就是未定义的//没有返回值，不会告诉应用哪里出错了 有未使用的内存但不能没能满足分配请求称为碎片，有内部碎片和外部碎片。内部碎片是有效载荷和已分配内存之差；外部碎片是必须要请求更大的虚拟内存分散映射多个块 放置已分配的块有三种 首次适配会在链表起始处留下小的碎片 下一次适配从上一次结束的地方开始搜索，比首次适配快，利用率低 最佳适配慢，分离式空闲链表组织，接近于最佳适配策略，不需要进行彻底的堆搜索 分配器通过调用sbrk函数，向内核请求额外的堆内存，分配器将额外的内存转换为一个大的空闲块，将这个块插入空闲链表中，然后将被请求的块放置到这个新的空闲块 合并空闲块：分配器采用立即合并或者推迟合并 带标记的合并 使用边界标记来合并前面的空闲块，在每个块的结尾处添加一个脚本是头部标记的一个副本，合并所有的前后空闲块情况的合并 将前面的块的已分配/空闲位存放当前块中多出来的低位，则已分配的块就不需要脚部了 显式空闲链表 将空闲块组织成一个某种形式的显式数据结构，实现这个数据结构的指针可以存放在空闲块的主体中 使用首次分配的时间从块总数的时间减少到空闲块数量的线性时间 释放块的时间可以是线性的，也可以是常数，取决于排序策略 一种方法是使用后进后出的方法来维护链表，将新释放的块放在链表头部，在常数时间内完成首次适配放置和释放块，以及有边界标记的合并 另一种方法是按照地址顺序来维护链表，释放块需要线性时间来搜索定位，比后进后出排序的首次适配有更高的内存利用率 显式链表的缺点是空闲块必须足够大，包含所有指针，以及头部和可能的脚部，导致更大的最小块的大小，提高内部碎片的程度 分离的空闲链表 使用分离存储来减少分配时间，将所有可能的块划分为大小类，每个大小类都有一个空闲链表，按照大小升序排列 简单分离存储：每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小 空闲块不分割不合并，不需要头部和脚部，分配和释放都在空闲链表的起始处，是单向的 如果链表为非空，分配器向系统请求一个固定大小的额外内存片，将这个片分成大小相等的块，将块链接起来形成新的空闲链表 释放一个块只要简单的将块插入相应的空闲链表的前部 任何块都需要唯一字段是每个空闲块中的一个字的succ指针，最大块的大小是一个字 分离配适：每个链表包含潜在的大小不同的块，是大小类的成员 分配块时，确定请求的大小类，对适当的空闲链表进行首次适配，查找合适的块，并可选地进行分割，将剩余部分插入适当的空闲链表中 如果没有找到合适的块，向系统请求额外的堆内存，从新的堆内存中分离出一块，将剩余部分放置在适当的大小类中 释放一个块执行合并，将结果存放到相应的空闲链表中 C标准库中的GNU malloc包就是采用的这种方法 伙伴系统：快速搜索和快速合并，缺点是可能导致显著的内部碎片 递归的二分割块，直到找到合适的块，将剩余的半块放置到合适的空闲链表中 C程序中常见的与内存有关的错误 间接引用坏指针 读未初始化的内存 允许栈缓冲区溢出：不检查输入串的大小写入栈中的目标缓冲器，这个程序就会有缓冲区溢出错误 假设指针和指向的对象是相同大小的 造成错位错误：常见的覆盖错误 引用指针而不是指针指向的对象 误解指针运算 引用不存在的变量 引用空闲堆块中的数据 引起内存泄露]]></content>
      <categories>
        <category>Intel Core i7/Linux内存系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟内存]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[虚拟内存 虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，为每个进程提供一个大的、一致的、私有的地址空间 虚拟内存的三个能力： 将主存看成是存储在磁盘上的地址空间的高速缓存，在主存中保留只保留活动区域，根据需要在主存和磁盘之间来回传送数据 为每个进程提供一致的地址空间，简化内存管理 保护每个进程的地址空间不被其他进程破坏 计算机内存被组织成M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址，使用物理地址访问内存称为物理寻址 虚拟寻址，CPU生成一个虚拟地址（Virtual Address,VA）来访问内存，这个虚拟地址在被传送到内存之前，先转换为物理地址 将一个虚拟地址转换成为物理地址的过程称为地址翻译 CPU芯片上的内存管理单元，利用存放在主存中的查询表来翻译虚拟地址，该表的内容由操作系统管理 地址空间是非负整数地址的有序集合：{0,1,2,3,…}，如果地址空间的整数是连续的，我们可以成之为线性地址空间，假设使用的是线性地址空间，在一个带虚拟内存的系统中，CPU从一个有N=2^n-1个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间：{0,1,2,…,N-1}，称为n位地址空间 系统的物理地址空间对应物理内存的M个字节：{0,1,2,3,…,M-1} 允许每个对象有多个独立的地址，每个地址都来自不同的地址空间 在任何时刻，虚拟内存被分为三个互不相交的子集：未分配的、缓存的、未缓存的 DRAM缓存组织：因为对磁盘访问时间都很长，DRAM缓存通常使用写回而不是直写 虚拟内存作为内存保护工具 在PTE上添加额外的许可位来控制对一个虚拟页面内容的访问 SUP表示进程必须运行在内核模式下才能访问该页，READ和WRITE控制页面的读写。如果违反许可条件会处罚保护故障，”段错误“ 虚拟内存作为内存管理的工具 操作系统通常为每个进程都提供一个独立的页表，有一个独立的虚拟地址空间，多个虚拟页面可以映射到同一个共享物理页面上 VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配 简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式，简化了连接器的设计和实现，允许链接器生成完全连接的可执行文件 简化加载：容易向内存中加载可执行文件和共享对象文件。将一组连续的虚拟也映射到任意一个文件中的任意位置的表示法称为内存映射，Linux提供mmp系统调用，允许应用程序自己做内存映射 简化共享：操作系统将不同进程中的适当的虚拟页面映射到相同的物理页面 简化内存分配：当一个运行在用户进程中的程序要求额外的堆空间时，操作系统分配一个适当数字个连续的虚拟内存页面，页面可以随机的分散在物理内存中 页 MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表的数据结构，判断虚拟页是否缓存在DRAM的某个地方及之后的措施，这个功能是由软硬件联合提供的，包括操作系统软件 页表将虚拟页映射到物理页，每次地址翻译器将虚拟地址转换为物理地址时都会读取页表，操作系统负责维护页表的内容，以及磁盘与DRAM之间来回传送页 虚拟空间中每个页在页表中的一个固定偏移量处都有一个PTE，PTE由一个有效位和n位地址字符串组成，有效位表明虚拟页是否被缓存在DRAM中。 如果设置了有效位，地址字段就表示DRAM中相应的物理页的起始位置 如果没有设置有效位，空地址表示虚拟页还没被分配 页面命中，使用PTE中的物理内存地址构造出这个字的物理地址 处理器生成一个虚拟地址，传送给MMU MMU生成一个PTE地址，并从高速缓存/主存请求得到它 高速缓存/主存向MMU返回PTE MMU构造物理地址，传送给高速缓存/主存 高速缓存/主存返回请求的数据字给处理器 DRAM缓存不命中称为缺页，缺页异常调用内核中的缺页异常处理程序，程序会选择一个牺牲页VP4，把它复制回磁盘，修改页表条目，然后从磁盘中复制VP3，复制VP3到内存中的PP3，更新PTE3，再次调用导致缺页的指令 缺页，硬件和操作系统内核一起完成** 处理器生成一个虚拟地址，传送给MMU MMU生成一个PTE地址，并从高速缓存/主存请求得到它 高速缓存/主存向MMU返回PTE PTE中有效位是0，触发异常，传递到缺页异常处理程序 缺页处理程序确定物理内存牺牲页，如果页面已经被修改了，换出到磁盘 缺页处理程序页面调入新的页面，更新内存的PTE 缺页处理程序返回到原来的进程，再次执行导致缺页的指令 磁盘和内存之间的传送页的活动叫做交换或者页面调度，当有不命中发生时，才换入页面这种策略称为按需页面调度，现代计算机系统都使用按需调度 局部性原则保证在任意时刻，程序趋向于在一个较小的活动页面集合上工作，这个集合称为工作集或者是常驻集合。良好的局部性保证虚拟内存系统能够工作的很好 地址翻译 CPU中的一个控制寄存器（Page Table Base Register,PTBR）指向当前页表 n位虚拟内存包含两个部分：一个p位的虚拟页面偏移（virtual page offset，VPO）和一个n-p位的虚拟页号（virtual page number,VPN） MMU利用VPN来选择适当的PTE，将页表条目中的物理页号和虚拟地址中的VPO串联起来，得到相应的物理地址 物理页面偏移（PPO）和VPO是相同的 利用TLB加速地址翻译 MMU包括一个关于PTE的小的缓存，称为翻译后备缓冲器，每行都保存着单个PTE组成的块。 TLB每一行都保存着单个PTE组成的块。 用于组匹配和行匹配的索引和标记字节是从虚拟地址中的虚拟页号中提取出来的。 TLB索引位和标记位组成了VPN TLB命中时包含的步骤： CPU产生虚拟地址 MMU从TLB中取出相应的PTE MMU将这个地址翻译成一个物理地址，并发送到高速缓存和主存 高速缓存和主存讲请求的字节返回CPU TLB不明中时，MMU必须从L1缓存中取出相应的PTE，新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目]]></content>
      <categories>
        <category>虚拟内存</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常控制]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E5%92%8C%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[异常控制和进程异常控制流 ak是某个指令Ik的地址，每次从ak到ak+1的过渡称为控制转移，这样的控制转移序列叫做处理器的控制流 Ik和Ik+1在内存中是相邻的，这种最简单的控制流是”平滑的序列”，平滑流的突变通常是跳转、调用和返回造成的 现代系统通过使控制流发生突变来应对系统的突变，将这些突变称为异常控制流(Exceptional Control Flow,ECF)。异常控制流发生在计算机系统的各个层次，ECF是操作系统用来实现I/O、进程和虚拟内存的基本机制 应用程序通过使用陷阱或者系统调用的ECF形式，向操作系统请求服务，操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其他进程系统的异常事件以及检测和响应这些事件 ECF是计算机实现并发的基本机制 异常发生于硬件和操作系统交界的部分，进程和信号位于应用和操作系统的交界处，非本地跳转是ECF应用层形式 异常 处理器检测到有事情发生时，通过一张交错异常表的跳转表，进行间接过程调用，到一个专门用来处理这类程序的操作系统子程序（异常处理程序），异常处理程序完成后根据引起异常的数据类型，发生以下3中情况的一种： 处理程序将控制返回给当前指令 处理程序将控制返回给当前指令的下一条指令 处理程序终止 异常处理 系统为每个类型的异常都分配一个唯一的非负整数异常号，系统启动后操作系统分配和初始化一张称为异常表的跳转表，条目k包含异常k的处理程序的地址，异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器中 异常程序处理程序运行在内核模式下，它们对所有系统资源都有访问权限 异常的类别异常可分为四类：终端、陷阱、故障和终止 硬件中断的异常处理程序称为中断处理程序。剩下三种异常是同步的，是执行当前指令的结果，我们把这类指令叫做故障指令 陷阱最重要的用途是在用户程序和内核之间提供一种像过程一样接口，称为系统调用。用户请求服务n时，执行syscall n，导致一个到异常处理程序的陷阱。 普通函数运行在用户模式中，用户模式限制了函数可执行的指令的类型，只能访问和调用函数相同的栈 系统调用运行在内核模式中，允许调用执行特权指令，访问内核中的栈 故障由错误的情况引起，可能被故障处理程序修正。故障发生时，处理器将控制转移给故障处理程序。如果能够处理和这个错误，将控制返回到引起故障的指令，重新执行。否则，处理程序返回内核的例程，终止引起故障的程序。 终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，DRAM或者SRAM位损坏发生的奇偶错误，处理程序将控制返回给一个abort例程，终止程序 Linux/x86-64系统中的异常 x86-64有256中不同的异常类型，0-31是Intel架构师定义的异常，32-255对应的是操作系统定义的终端和陷阱 C程序syscall函数可以直接调用任何系统调用，但是一般使用系统调用和相关联的包装函数统称为系统级函数 Linux系统调用的参数一般都通过寄存器而不是栈传递。%rax包含系统调用，%rdi、%rsi、%rdx、%r10、%r9、%r8分别包含第1-6个参数，从系统调用返回时，寄存器%rcx和%r11会被破坏，%rax包含返回值(-4095到-1表示发生错误，对应负值的errno) 进程 异常是操作系统允许内核提供进程概念的基本构造块 进程是执行中的程序的实例，系统中的每个程序都运行在某个进程的上下文中，上下文由程序正确运行所需的状态组成。这个状态包括内存中程序的代码和数据，栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流 一个私有的地址空间 PC值序列称为逻辑控制流(逻辑流），一个逻辑流的执行在时间上与另一个流重叠，称为并发流，一个进程和其他进程轮流运行的概念称为多任务，一个进程执行它的控制流一部分的每一个时间段称为时间片，多任务也叫时间分片，两个流并发的运行在不同的处理器核或者计算机上，称它们为并行流 进程为每个程序提供私有地址空间，空间中某个地址相关联的内存字节不能被其他进程读或者写 处理器通常使用控制寄存器的一个模式位来限制进程当前享有的特权 设置了模式位时，进程运行在内核模式，可以执行指令集中的任何指令，可以访问系统中的任何内存位置 没有设置模式位，进程运行在用户模式中，进程不允许执行特权指令，必须通过系统调用接口间接地访问内核代码和数据 Linux提供了/proc文件系统，允许用户模式进程访问内核数据结构的内容。/proc文件系统将内核数据结构的内容输出为用户可读的文本层次结构，2.6版本的Linux引入了/sys文件系统，输出关系系统总线和设备的低层信息 上下文切换是一种较高层形式的异常控制流，可以实现多任务。内核为每个内存维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构(如，地址空间的页表、包含当前进程信息的进程表、进程已打开文件的信息的文件表) 上下文切换： 保存当前进程的上下文 恢复先前被抢占的进程的上下文 将控制转移给这个新恢复的进程 进程控制 进程有唯一的进程ID(整数)，getpid函数返回进程的PID 进程的三个状态： 运行，在CPU上执行或者等待被执行且最终被调度 停止，进程被挂起，且不会被调度，停止信号SIGSTOP/SIGTSTP/SIGTTIN/SIGTTOU，再次开始信号SIGCONT 终止，进程永远终止，收到信号的默认行为是终止进程、从主程序返回、调用exit函数（exit是以status退出状态来终止进程的） 父进程调用fork函数来创建一个新的运行的子进程，两者的PID不同 子进程得到与父进程用户级虚拟地址空间相同的但独立的一个副本，包括代码和数据段、堆、共享库以及用户栈 子进程还获得与父进程任何打开文件描述符相同的副本，子进程可以读写父进程打开的任何文件 每个进程都只属于一个进程组，进程组由一个正整数进程组ID来标识，getpgrp函数返回当前进程的进程组ID 子进程和父进程同属于一个进程组 一个进程可以通过使用setpgid函数来改变自己或其他进程的进程组ID123456#include&lt;unistd.h&gt;int setpgid(pid_t pid,pid_t pgid);//将进程组pid改成pgid//如果pid为0，则使用当前进程的PID//如果pgid为0，用pid指定的进程PID作为进程组IDsetpgid(0,0);//创建一个新的进程组ID15213（调用进程），并且进程15213加入这个新的进程组中 父进程和子进程的异同点 fork被调用一次会返回两次，一次在父进程中返回子进程的PID，另一次在子进程中返回0 调用fork，父进程和子进程是并发运行的独立进程 在两个进程均没有发生改变之前，父进程和子进程有相同但独立的地址空间 子进程和父进程共享文件 回收子进程 子进程退出但未被回收的状态被称为僵死过程 父进程终止子进程的过程：内核将子进程的退出状态传递给父进程，抛弃已终止的进程 如果父进程终止了，内存会安排init进程成为它的孤儿进程的养父，init进程的PID为1，是所有进程的祖先。进程可以通过waitpid函数来等待子进程终止或停止123456789#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t waitpid(pid_t pid,int *statusp,int options);/*默认情况下（options=0），waitpid函数挂起调用进程的执行，直到等待集合中的一个子进程终止，返回子进程的PID*//*判断等待集合的成员：1）pid&gt;0等待集合就是一个单独的子进程，进程ID=pid；2）pid=-1，等待集合是由父进程的所有子进程组成的*//*通过将option设为常量WNOHANG/WUNTRACED/WCONTINUED的各种组合来修改默认行为*//*如果statusp参数是非空的，waitpid就会在status中放上关于导致返回子进程的状态信息，status就是指向statusp的值*//*wait.h头文件定义了status参数的几个宏*/ options常量组合status参数的几个宏 错误条件 如果调用进程没有子进程，waitpid返回-1，并设置errno为ECHILD 如果waitpid函数被一个信号中断，则返回-1，设置errno为EINTR 让进程休眠 1234567#include &lt;unistd.h&gt;unsigned int sleep(unsigned int secs);/*如果请求的时间量到了，sleep返回0，否则返回剩下的秒数*//*系统让调用函数休眠，直到该进程收到一个信号*/int pause(void); 加载并运行程序 123456int execve(const char *filename,const char *argv[],const char *envp[]);/*execve函数在当前进程的上下文加载并运行一个新程序,如果成功则不返回，如果错误则返回-1*//*参数变量表argv和环境变量表envpargv指向一个以null为结尾的指针数组，每个指针都指向一个参数字符串，argv[0]是可执行目标文件的名字envp变量指向一个以null为结尾的指针数组，每个指针指向一个环境变量，每个串形如&quot;name=value&quot;的名字值对*/ 123456789101112int main(argc,char **argv,char **envp);//main函数的三个参数//argc给出argv[]数组中非空指针的数量，argv指向argc[]数组中的第一个条目，envp指向encp[]数组中的第一个条目#include &lt;stdlib.h&gt;char *getenv(const char *name);//getenv函数在环境数组中搜索字符串，如果找到就返回value的指针，否则返回NULL//如果环境数组包含一个形如“name=oldvalue”的字符串int setenv(const char *name,const char *newvalue,int overwrite);//用newvalue代替oldvalue，只有overwrite非零时才会这样，如果name不存在，将“name=oldvalue”添加到数组中void unsetenv(const char *char);//删除字符串 shell执行一系列读/求值，然后终止，读步骤读取来自用户的一个命令行，求值步骤解析命令行，代表用户运行程序 信号 Linux信号是更高层的软件形式的异常，允许进程和内核中断其他进程 每种信号类型都对应于某种系统事件，低层的硬件异常是由内核处理程序处理的，通常对用户进程是不可见的，系统提供了一种机制通知用户发生了这些异常 传送信号到目的进程是由两个不同步骤组成的： 发送信号，内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程，发送信号的两个原因，内核检测到一个系统事件或是一个进程调用了kill函数 接收信号，目的进程被内核强迫以某种方式对信号的发送做出反应，进程可以忽略这个信号，终止或通过执行一个称为信号处理程序的用户层函数捕获这个信号4.一个发出而没有被接收的信号叫做待处理信号，在任何时刻，一种类型至多有一个待处理信号，如果进程有一个待处理信号k，那么接下来所有发送到这个进程的信号k都会被丢弃 一个进程可以有选择的阻塞接收某种信号，当一种信号被阻塞时，仍可以被发送，但是产生的待处理信号不会被接收。一个待处理信号只能被接收一次，内核为每个进程在pending位向量中维护待处理信号的集合 blocked位中维护者被阻塞的信号集合 发送信号 用/bin/kill程序发送信号/bin/kill -9 15213 #发送信号9到进程15213/bin/kill -9 -15213 #一个为负的PID会导致信号被发送到进程组PID中的每个进程 从键盘发送信号ls | sort#常见由两个进程组成的前台作业，两个进程通过Unix管道连接，一个进程运行ls程序，另一个运行sort程序 shell为每个作业创建一个独立的进程组，进程组ID通常取自作业中父进程中的一个 用kill函数发送信号 123456#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid,int sig);//若pid&gt;0，kill函数发送信号sig给进程pid//若pid=0，kill函数发送信号sig给调用进程所在进程组的每个进程，包括调动进程自己//若pid&lt;0，kill函数发送信号sig给进程|pid|中的每个进程 用alarm函数发送信号 123456#include &lt;unistd.h&gt;unsinged int alarm(unsigned int secs);//安排内核在secs秒后发送一个信号给调用进程，如果secs=0，调度不会安排新的闹钟//在任何情况下，对alarm的调用都会取消任何待处理的（pending）闹钟//返回任何待处理闹钟在发送前还剩下的秒数//如果没有任何待处理的闹钟，就返回0 接收信号 每个信号都一个预定义的默认行为 进程终止 进程终止并转储内存 进程停止知道被SIGCONT信号重启 进程忽略该信号 signal信号 12345678#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandler_t signal(int signum,sighander_t handler);//signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为//如果handler是SIG_ING，忽略类型为signum的信号//如果handler是SIG_DFL，类型为signum的信号行为恢复为默认行为//否则handler就是用户定义的函数的地址，这个函数被称为信号处理程序//通过处理程序把地址传递到signal函数而改变默认行为，叫做设置信号处理程序 调用信号处理程序被称为捕获信号，执行信号处理程序被称为处理信号 进程捕获一个类型为k的信号，会调用信号k设置的信号处理程序，一个整数参数被设置为k，这个参数允许同一个处理函数捕获不同类型的信号 阻塞和解除阻塞信号 隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理信号类型的待处理信号 显式阻塞机制：应用程序使用sigprocmask函数和它的辅助函数，明确的阻塞和解除阻塞选定的信号 1234567891011121314#include &lt;signal.h&gt;int sigprocmask(int how,const sigset_t *set,sigset_t *oldset);//sigprocmask会改变当前阻塞的信号集合，以来与how值//SIG_BLOCK：把set中的信号添加到blocked中(block=block|set)//SIG_UNBLOCK：从block中删除set中的信号(block=block&amp;~set)//SIG_SETMASK：block=set//如果oldset非空，那么blocked位向量之前的值保存在oldset中int sigemptyset(sigset_t *set);//初始化set为空集合int sigfillset(sigset_t *set);//把每个信号都添加到set中int sigaddset(sigset_t *set,int signum);//把signum添加到set中int sigdelset(sigset_t *set,int signum);//把signum从set中删除int sigismember(const sigset_t *set,int signum);//如果signum是set成员返回1，否则返回0 通过阻塞信号和取消阻塞信号来避免并发错误 编写信号处理程序 主程序和信号处理程序并发运行，相互干扰 信号处理中产生输出唯一安全的方法是使用write函数，为了绕开这个限制，我们开发了一些安全的函数，称为SIO包，用来在信号处理程序中打印简单的信息12345#include &quot;csapp.h&quot;ssize_t sio_putl(long v);//向标准输出传送long类型数ssize_t sio_puts(char s[]);//向标准输出传送字符串void sio_error(char s[]);//打印一条错误信息并终止 处理程序尽可能的简单 在处理程序中只调用异步信号安全的函数，是可重入的或者不能被信号处理程序终端 保存和恢复errno，在进入处理程序时将errno保存在一个局部变量中，在处理程序返回时恢复它 阻塞所有信号，保护对共享全局数据结构的访问，保证处理程序不会中断指令 用volatile生声明全局变量，强迫编译器每次在代码中引用g时都要从内存中读取g的值 用sig_atomic_t声明标志，保证读和写是原子的（不可中断的），volatile sig_atomic_t flag; 正确的信号处理，不可以用信号对其他进程中发生的之间计数，相同类型的信号可能会丢失 可移植的信号处理：1）不同的系统有不同的信号处理语义；2）系统调用可以被中断 Posix标准定义了sigaction函数，允许用户设置信号处理时明确指定他们想要的信号处理语义123#include &lt;signal.h&gt;int sigaction(int signum,struct sigaction *act,struct sigaction *oldact);//一个更简洁的方式，用Signal包装函数调用sigaction Signal包装函数设置了一个信号处理程序，其信号处理语义如下： 只有这个处理程序当前正在处理的那种类型的信号被阻塞 信号不会排队的等待 中断的系统调用会自动重启 一旦设置了信号处理程序，会一直被保持，直到Signal带着handler参数为SIG_IGN或者SIG_DFL被调用 显式的等待信号 父进程设置SIGINT和SIGCHLD的处理程序，然后进入一个无限循环 阻塞了SIGCHLD信号，避免了竞争 创建了子进程之后，将pid设为0，取消阻塞SIGCHLD，然后以循环的方式等待pid变为非零 子进程终止后，处理程序回收它，以非零的PID赋值给全局pid变量，终止循环，父进程开始其他工作，然后开始下一次迭代 使用sigsuspend，修补循环造成的浪费资源12345#include &lt;signal.h&gt;int sigsuspend(const sigset_t *mask);//暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号//如果信号的行为是终止的，那么sigsuspend从处理程序返回//如果信号的行为是运行一个处理程序，sigsuspend从处理程序返回，恢复调用sigsuspend时原有的阻塞集合 非本地跳转 将控制直接从一个函数转移到当前正在执行的函数，而不需要经过正常调用-返回序列，通过setjmp和longjmp函数来提供的 非本地跳转允许从一个深层嵌套的函数调用中立即返回，通常是检测到某个错误情况引起的12345678910#include &lt;setjmp.h&gt;int setjmp(jmp_buf env);//在env缓冲区中保存当前调用环境，供后面的longjmp使用，返回0，stejmp返回的值不能被赋值给变量//调用环境包括程序计数器、栈指针和通用目的寄存器int sigsetjmp(sigjmp_buf env,int savesigs);void longjmp(jmp_buf env,int retval);void siglongjmp(sigjmp_buf env,int retval);//longjmp函数从env缓冲区中恢复调用环境，触发从最近一次初始化env的setjmp调用的返回，然后setjmp返回并带有非零的返回值retval//setjmp调用一次，但是返回多次；longjmp调用一次，但是从不返回 操作进程的工具 STRACE：打印正在运行的程序和子进程调用的每个系统调用的轨迹，用-strace编译程序 PS：列出当前系统中的进程（包括僵死程序） TOP：打印出关于当前进程资源使用的信息 PMAP：显示进程的内存映射 /proc：虚拟文件系统，以ASCII文本格式输出大量内核数据]]></content>
      <categories>
        <category>异常控制和进程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链接]]></title>
    <url>%2F2019%2F04%2F05%2F%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[链接 链接将代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载(复制)到内存并执行 链接可以执行与编译时、加载时、运行时 早期的计算机系统通常需要手动链接，现在计算机系统通产由链接器自动执行 链接器将大型程序分解为小的模块，可以分离编译 有助于构造大型程序 错误的定义多个全局变量的程序通过链接器不会产生警告 理解作用域规则 能够理解其他重要的系统概念 利用共享库 编译器驱动程序 要用GNU编译系统构造示例程序，在shell中输入一下命令，调用GCC驱动程序：gcc -Og -o prog main.c sum.c 驱动程序生成main.o和sum.o，最后运行链接器程序ld，将文件和必要的系统文件组合起来，创建一个可执行的目标文件prog：ld -o prog [system object files and args] /tmp/main.o/tmp/sum.o 执行可执行文件prog：./prog shell调用操作系统中的一个叫做加载器的函数，将可执行文件prog的代码和数据复制到内存，将控制转移到这个程序的开头 静态链接 Linux LD静态链接器，以一组可重定位的目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出 构造可执行文件链接器必须完成两个任务：1）符号解析；2)重定位 符号解析，符号解析的目的是为了使每个符号引用正好和一个符号定义相关联； 重定位，编译器和汇编器生成次若干个地址0开始的代码和数据节。链接器通过每个符号定义与一个内存位置关联来重定位这些节，然后修改所有对这些符号的引用，使他们指向这个内存位置。链接器使用汇编器产生的重定位条目的详细指令，不加甄别的执行这样的重定位 目标文件纯粹是字节块的集合 目标文件 目标文件有三种形式：可重定位目标文件、可执行目标文件、共享目标文件 可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件 可执行目标文件：包含二进制代码和数据，其形式可以直接被复制到内存并运行 共享目标文件：一种特殊类型的可重定位目标文件，在加载或运行时被动态的加载进内存并链接 编译器和汇编器生成可重定位目标文件，链接器生成可执行目标文件 目标模块是字节序列，目标文件是以文件形式存放在磁盘中的目标模块 符号解析 每个可重定义的目标模块m都有一个符号表，包含m定义和引用的符号的信息，在链接器的上下文中有三种不同的符号： 由模块定义并能被其他模块引用的全局符号，全局链接器符号对应于非静态的C函数和全局变量 由其他模块定义并被模块m引用的全局符号，这些符号被称为外部符号，对应其他模块中定义的非静态的C函数和全局变量 只被模块m定义和引用的局部符号，对应带static属性的C函数和全局变量 可以利用static变量隐藏变量和函数名字 符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号 每个符号被分配到目标文件的某个节，由section字段表示，这个字段也是到节头部表的一个索引 可重定位文件中有三个特殊的伪节： ABS表示不该被重定位的符号 UNDEF表示未定义的符号（在本目标模块中引用，在其他模块中定义） COMMON表示还未被分配位置的未初始化的数据目标（value给出对其目标，size给出最小的大小） GNU READELF是一个查看目标文件内容的很方便的工具 重载中，将每个函数和参数列表组合编码成一个对链接器来说唯一的名字，这种编码过程称为重整；相反的过程称为恢复 多个模块定义多个同名全局变量，编译时编译器向汇编器输出每个全局符号：函数和已初始化的全局变量是强符号、未初始化的全局变量是弱符号 不允许有多个同名的强符号 如果有一个强符号多个弱符号，选择强符号 如果有多个弱符号，则从多个弱符号中随机选一个 与静态库链接 将所有相关目标打包成一个单独的文件称为静态库，可以用作链接器的输入，当链接器构造一个输出的可执行文件时，只复制静态库里被应用程序引用的目标模块 相关函数可以被编译成独立的目标模块，封装成一个独立的静态库文件。链接时只复制被程序引用的模块，减少了可执行文件在内存中的大小；应用程序员只需要包含较小的库函数的名字 Linux中，静态库以一种称为存档的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部来描述每个成员目标文件大小和位置。存档文件名以.a为标识 123456gcc-c addvec.c multvec.car rcs libvector.a addvec.o multvec.c #创建静态库gcc -static -o prog2c main2.o ./libvector.a #static参数高速编译器驱动程序，链接器创建一个完全链接的可执行文件，可以加载到内存并运行#在当前目录下查找libvector.a 关于库的一般准则是将他们放在命令行的结尾，如果库的成员是相互独立的，则库可以以任何顺序放置在命令的结尾处；否则需要对库排序；如果需要满足依赖需求，可以在命令行上重复库；另一种方法是将其中某些文件合并成一个单独的存档文件 重定位 合并输入模块，为每个符号分配运行时地址，重定位分为两步： 重定位节和符号定义：将所有相同类型的节合并为同一类型的新聚节，完成后程序的每条指令和全局变量都有唯一的运行时内存地址 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得他们只想正确的运行时地址 重定位条目-汇编器遇到对最终位置未知的目标引用，就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用，就会生成一个重定位条目高速链接器将目标文件合并成可执行文件时如何修改这个引用123456typedef struct&#123; long offset; //offset是被修改的引用的节偏移 long type:32, //type告诉链接器如何修改新的引用 symbol:32; long addend; //addend是一个有符号常数&#125;Elf64_Rela; ELF定义了32种不同的重定位类型，其中两种基本的定位类型：R_X86_64_PC32和R_X86_64_32，两种重定位类型都支持x86_64小型代码模型 R_X86_64_PC32:重定位使用一个32位PC相对地址的引用，PC值通常是下一条指令在内存中的地址 R_X86_64_32：重定位使用一个32位的绝对地址的引用 重定位符号引用 可执行目标文件是完全链接的，ELF可执行文件被设计的很容易加载到内存，可执行文件的连续的片被映射到连续的内存段。程序头部表描述了这种映射关系 加载可执行目标文件 ./prog通过调用驻留在存储器中称为加载器的操作系统代码来运行它，任何Linux程序都可以通过调用execve函数来调用加载器。将程序的代码和数据复制到内存并且从程序入口运行的过程称为加载 每个Linux程序运行都有一个内存映像，在Linux x86-64系统中代码段总是从地址0x400000处开始，后面是数据段，运行时，堆在数据段之后通过调用malloc库往上增长 内存映像： 在程序头部表的指导下，加载器将可执行文件的片复制到代码段和数据段；加载器跳转到程序的入口点(_start函数的地址)，这个函数在系统目标文件ctrl.o中定义；_start函数调用系统启动函数__libc_start_main，定义在libc.so中；初始化执行环境，调用用户层main函数 动态链接共享库 共享库是一个目标模块，在运行或加载时可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由动态链接器执行的。 共享库也称为共享目标，Linux系统中通常用.so后缀，微软的操作系统使用的动态链接库(DDL) 给定文件系统中，一个库只有一个.so文件，所有引用该库的可执行目标文件共享这个文件。在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享 gcc -shared -fpic -o libvector.so addvec.c multvec.c #-shared选项只是链接器创建一个共享目标文件gcc -o prog21 main2.c ./libvector.so #链接到示例程序中 加载器加载执行prog21，prog21包含一个.interp节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标，加载和运行这个动态链接器。 动态链接器通过执行下面的重定位来完成链接任务 重定位libc.so的文本和数据到某个内存段 重定libvector.so的文本和数据到另一个内存段 重定位prog21中所有对由libc.so和libvector.so定义的符号的引用 动态链接器将控制传递给应用程序，共享库的位置不会再改变了 应用程序可能在运行时要求动态链接器加载和链接某个共享库，无需在编译时将这些库链接到应用中 将每个生成的动态内容的函数打包在共享库中，当一个来自Web浏览器请求到达时，服务器动态地加载和链接适当的函数，然后调用它们。函数会一直缓存在服务器的地址空间中，只需要简单的函数调用的开销就可以处理随后的请求。在运行时无需停止服务器就更新已存在的函数 位置无关代码(Position-Independent Code,PIC) 多个进程如何共享一个程序的副本： 给每个共享库分配一个预备的专用地址空间片，但是有很多严重的问题 编译共享模块的代码块，可以把它们加载到内存的任何位置而无需修改，无数个进程可以共享一个共享模块的单一副本。 PIC数据引用：在数据段开始的地方创建一个全局偏移变量表(Global Offset Table,GOT)，GOT是数据段的一部分 每个被目标模块引用的全局数据目标都有一个8字节条目 编译器为GOT中的每个条目生成一个重定位记录 在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址 每个引用全局变量的目标模块都有自己的GOT3.PIC函数调用：通过延迟绑定，将过程地址的绑定延迟到第一次调用该过程时。是通过GOT和过程链接表(Procedure Linkage Table,PLT)之间的交互来完成的。PLT是代码段的一部分 目标模块调用定义在共享库的任何函数都有自己的GOT和PLT]]></content>
      <categories>
        <category>链接</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础2]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[操作系统基础2流水线 SEQ将不同的指令所需的步骤组织成统一的流程，可以用很少的硬件单元以及一个时钟来控制计算的顺序，但是太慢了，不能充分利用硬件单元，引入流水线获得更好的性能 猜测分支方向并根据猜测开始取指的技术成为分支检测 流水线冒险 数据冒险：下一条指令会用到这条指令的计算出的结果，可以用暂停、转发来避免数据冒险 控制冒险：一条指令要确定下一条指令的位置，当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时会出现控制冒险 内存读在流水线中发生的比较晚，将暂停和转发结合起来，避免加载/使用数据冒险，这种方法称为加载互锁 按照指令进入流水线的顺序列出，不是按照在程序中出现的顺序，预测跳转指令会出现分支，去除位于跳转指令目标处的指令，在下一个周期取出目标指令后的那条指令，指令到达执行阶段指令会改变条件码，在下一个周期就能取消错误指令（指令排除） 异常处理 指令集结构包括三种不同的内部产生的异常，halt指令、非法的指令和功能码组合的指令、取指或数据读写试图访问一个非法地址 完整的处理器应该能够处理外部异常 将导致异常的指令称为异常指令，流水线中越深的指令引起的异常优先级越高 在流水线结构中加入异常处理逻辑，状态码Stat，当处于访存或者写回阶段指令导致的异常，流水线控制逻辑必须禁止更新条件码寄存器或数据内存 保证第一个出现异常的指令第一个到达写回阶段，此时程序停止 性能分析 计算PIPE执行一条指令所需要的平均时钟周期数的估计值，来量化冒险产生的性能损失，这种衡量方法称为CPI CPI=1.0+lp+mp+rp 每种处罚都是以该种原因产生的气泡数/执行指令总数Ci，其中load penalty #加载处罚，mispredicited branch penalty #预测错误分支处罚，return penalty #返回处罚 优化程序性能 度量标准：每元素的周期数CPE，表示每个时钟周期执行了多少条指令 提高性能的方法：消除循环低效率、减少过程调用、消除不必要的内存引用 现代处理器 在实际的处理器同时处理多条指令，称为指令级并行，会出现延迟界限(在下一条指令开始之前这条指令必须结束)、吞吐量界限(处理器功能单元的原始计算能力) 整个处理器主要分为两个部分，指令控制单元ICU和执行单元EU 指令译码逻辑接收实际的程序指令，转换为一组基本操作(微操作)，EU接收来自取指单元的指令，每个时钟周期可以接收多个操作，这些操作会被分派到一组功能单元中，这些功能单元专门用来处理不同的类型 退役单元 退役单元记录正在进行的处理,确保遵循机器级程序的顺序语义。 其中的寄存器文件包含整数、浮点数、和最近的SSE和AVX寄存器是退役单元的一部分 退役单元控制着寄存器的更新，指令译码时，关于指令的信息被放置在一个先进先出的队列中，所有对寄存器的更新只有等指令退役时才会发生 指令操作完成且引起这条指令的分支点被确认为预测正确，这条指令退役，所有对程序的寄存器的更新被实际执行 或者引起该指令的分支点被确认预测错误。这条指令被清空，丢弃所有计算结果 控制操作数在执行单元间传送最常见的机制是寄存器重命名，重命名表只包含关于有未进行写操作的寄存器条目，这种机制可以被认为是一种数据转发 功能单元的性能： 运算由以下数值刻画 延迟：完成运算需要的时间 发射时间：两个连续的同类型操作运算之间需要的最小时钟周期数 容量：执行该运算的功能单元的数量 用CPE值的两个基本界限来描述算术运算的延迟、发射时间和容量对合并函数的性能的影响，延迟界限给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值，根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限 将可以访问到的寄存器分为4类 只读：只能作为源值，也可以用来计算内存地址，但是在循环中不会被修改，循环combine4中的只读寄存器是%rax 只写：作为数据传送操作的目的 局部：在循环内部修改和使用，迭代和迭代之间不相关，如上例中的条件码寄存器 循环：这些寄存器既作源值也作目的，一次迭代中的值会在另一次迭代中用到，循环combine4中的循环寄存器是%rdx和%xmm0用程序的数据8. 流图形化的分析现代处理器执行的机器级程序性能,可以看到制约程序性能的主要因素是mul的链 循环展开通过增加每次迭代的计算的元素的数量来减少迭代次数 提高并行性，如：多个累积变量，将累乘分为奇数项乘积和偶数项乘积，称为2*2循环展开（并行执行） 程序性能的限制因素： 寄存器溢出：循环变量的个数超过了可用的寄存器数量，程序就必须在栈上分配空间，内存的读取比寄存器慢的多 分支预测错误：在使用投机执行的处理器中，如果发生预测就要丢弃所有投机执行的结果，在正确的位置重新开始取指令的过程，会引起错误处罚，再重新开始有用的结果之前，必须重新填充流水线。分支预测逻辑会产生很差的性能，使用条件操作来计算值，使用可以表达条件行为的方法，能够直接翻译成条件传送 存储单元包含一个存储缓冲区，包含发射到存储单元还没有完成的存储操作的地址和数据，这里的完成包括更新数据高速缓存。提供这样一个缓冲区，使得一系列存储操作不必等待每个操作都更新高速缓存就能执行 性能提高技术 消除连续的函数调用 消除不必要的内存引用 低级优化：展开循环降低开销、利用多个累积变量和重新结合等技术找到到方法提高指令集并行、使用功能性的风格重写条件操作 重新排列循环以提高空间局部性 Unix系统提供了一个剖析程序GPROF，产生两种形式的信息：确定程序中的每个函数花费了多少CPU时间、计算每个函数被调用的次数，三个步骤如下： 程序必须为剖析而编译和链接，命令行-pg，优化标志-Og确保正确跟踪函数调用 程序运行产生文件gmom.out 调用GPROF来分析gmon.out中的数据 GPROF的属性 计时不是很准确，计时机制是很简单的间隔计数 假设没有执行内联替换，则调用信息相当可靠 默认情况下不会对库函数计时 存储器层次结构 计算机程序称为局部性的基本属性，具有良好局部性的程序倾向于一次又一次的访问相同的数据项集合，或倾向于访问临近的数据项集合，具有良好局部性的程序更倾向于向存储器层次中较高层次的处访问数据项 在硬件层，局部性原理允许计算机设计者通过引入告诉缓存存储器的小而块的快速存储器来保存最近被引用的指令和数据项，提高对主存的访问速度。 每隔k个元素访问，称为步长为k的引用模式，随着步长的增加，空间局部性下降。 存储器层次结构将k+1层的存储器划分为连续的数据对象组块，称为块，块可以是固定大小的也可以是可变大小的，将k层划分为较少的块的集合，块的大小和k+1层一样，数据总是以块为大小在第k层和k+1层之间来回复制 缓存命中： 程序需要k+1层中的某个数据对象d，首先在k层查找，如果d刚好缓存在k层中，则成为缓存命中 缓存不命中： 当k层中没有数据对象d，第k层的缓存从第k+1层缓存中取出包含d的那个块，若k层的块已经满了，则覆盖其中一个块(称为替换或者驱逐)，由替换策略来决定替换哪个块。缓存不命中的种类如下： k层缓存为空，空的缓存称为冷缓存，此类不命中称为强制不命中或冷不命中 发生不命中后，k层缓存必须执行某个放置策略，确定从k+1层取出的块放在哪里，靠近CPU的硬件缓存通常使用更严格的放置策略，将k+1层的某个块限制放置在第k层的一个小的子集中，这种策略会引起冲突不命中 按照一系列阶段（循环）来运行，每个阶段访问缓存块的某个相对稳定的集合，这个块的合集称为这个阶段的工作集，工作集的大小超过缓存的大小时，缓存会经历容量不命中 高速缓存存储器 高速缓存结构可以用元素(S,E,B,m)来表示：每个存储器有m位，形成M=2^m个地址，机器的告诉缓存被组织成S=2^s个高速缓存组的数组，每个组包含E个高速缓存行，每行有B=2^b字节的数据块组成，一个有效位指明这个行是否包含有意义的信息，t=m-b+s个标记位，唯一的标识存储在高速缓存行中的块，高速缓存的大小时所有块的大小的和C=S×E×B 根据每个组的高速缓存行数E将高速缓存分为不同的类，每组只有一行的高速缓存称为直接映射高速缓存 高速缓存确定一个请求是否命中分为三步：1）组选择 2）行匹配 3）字抽取 直接映射高速缓存中的组选择：选中行 直接映射高速缓存中的行匹配：行的有效位设置，得到缓存命中，另一方面，如果有效位没有设置或者标记不匹配得到一个缓存不命中 直接映射高速缓存中的字选择：确定所需要的字是从块中哪里开始的 直接映射高速缓存中不命中时的行替换：从存储器结构的下一层请求块，将新的块存储在组索引位指示的组中的一个高速缓存行 标志位和索引位连起来唯一标识内存中的所有块，多个块映射到同一个高速缓存组，映射到高速缓存组的块由标记位唯一的标识 直接映射高速缓存中的冲突不命中：书page431，数组x和y不断交替加载到同一块内存，高速缓存反复加载和驱逐相同的高速缓存组，称为抖动 使用中间位作为索引，相邻的块会被映射到不同的高速缓存行 写一个已经缓存的字(写命中） 可以直写，只写会引起总线流量 可以使用写回，尽可能的推迟更新，只有替换算法要驱逐更新过的块时，才写到低一层中，但是这种方法增加了复杂性，高速缓存要额外维护一个额外的修改位 处理写不命中 写分配：加载低一层的块到高速缓存中，然后更新这个块 非写分配：避开高速缓存，直接写到低一层块中 直写高速缓存通常是非写分配的，写回高速缓存通常是写分配的 真实的高速缓存层次结构的解剖 只保存指令的高速缓存称为 i-cache 只保存程序数据的高速缓存称为 d-cache 既保持指令也保存数据的高速缓存称为统一的高速缓存 unifiled-cache 现代处理器包括独立的i-cache和d-cache，i-cache通常只读，比较简单。针对不同的访问模式优化两个高速缓存 高速缓存参数的性能影响 不命中率、命中率、命中时间、不命中处罚 高速缓存大小、块大小、相联度、写策略 高速缓存友好的代码 局部性比较好的程序更容易有更低的不命中率 让最常见的情况运行的更快 减少每个循环内部的缓存不命中的数量]]></content>
      <categories>
        <category>操作系统基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础1]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[操作系统基础1编译系统分为四个阶段： 预处理器，#include包含的程序直接插入到程序，对预定义的常量等进行替换，还有内联函数的调用 编译器，将程序语言变成汇编语言 汇编器，将汇编语言翻译成机器语言 链接器，调用了printf得到可执行的hello文件 指令 x86_64是目前笔记本和台式机最常用的处理器的机器语言，x86-64的指令长度为1-15位，设置指令的格式，将字节唯一的解码成机器指令 x86-64的中央处理单元包含一组16个存储64位值的通用目的存储器 程序计数器：给出下一条指令在内存中的位置 整数寄存器文件：包含16个命名位置，存储64位值 条件码寄存器保存最近执行的算术或逻辑运算符指令的状态信息 向量寄存器存放一个或多个整数或浮点型的值 Linux命令行 123gcc -S mstore.c #查看汇编代码，产生mstore.s汇编文件gcc Og -s -masm=intel mstore.c #产生函数multstore的Intel格式的汇编代码objdump -d mstore.o #反汇编器得到代表指令的字节值 GNU调试工具GDB 12345678910111213141516171819202122232425gdb x/14xb multstore #显示函数multstore14个16进制表示的字节,GNU调试工具GDBgdb prog #启动gdbquit #退出gdbrun #运行程序kill #停止程序break mulstore #在函数入口处设置断点break * 0x400540 #在地址位置处设置断点delete 1 #删除断点1delete #删除所有断点stepi #执行一条指令stepi 4 #执行4条指令nexti #以函数调用为单位，执行一条指令continue #继续执行finish #运行到当前函数返回disas #反汇编当前函数disas mulstore #反汇编当前函数disas 0x400544 #反汇编位于地址附近的函数disas 0x400540,0x40054d #反汇编位于地址范围内的代码print /x \$rip #以十六进制输出十六进制输出程序计数器的值print $rax #以十进制输出%rax的内容x/2g 0x7fffffffffe818 #检查从地址开始的2字x/20 mulstore #检查函数的前20个字节info frame #有关当前栈帧的信息info registers #所有寄存器的值help #获取有关GDB的信息 指令集是CPU用来计算和控制计算机系统的一套指令集合 把许多不同的指令划分成指令类，每一类执行相同的操作，操作数大小不同 指令可以有多个操作数：立即数 -577或0x1F；寄存器，表示某个寄存器的内容；内存引用，根据计算出来的地址访问某个内存位置 源操作数指定的值是一个立即数，目的操作数指定一个位置，传送指令的两个操作数不能都是内存的位置 C语言中的地址就是指针，间接引用指针就是把指针放在寄存器中，内存引用寄存器，局部变量x通常保存在寄存器中而不是内存中 算术和逻辑指令操作 ADD指令集是加法指令 leaq #加载有效地址，目的操作数必须是一个寄存器 移位操作的第二项给出操作数，移位量可以是一个立即数或者存放在单字节寄存器%cl 控制指令操作 jump #改变机器代码指令的执行顺序 CF #进位标志 最近的操作使最高位得到进位 ZF #零标志 最近的操作结果得到0 SF #符号标志 最近的操作结果得到负数 OF #最近的操作导致补码溢出 CMP和TEST两类指令只设置条件码而不改变任何其他寄存器，CMP指令根据两个操作数之差设置条件码，不更新目的寄存器 SET指令，将字节设置为0或者1 条件指令 条件跳转只能是直接跳转 跳转目标用符号标号书写，跳转指令有几种不同的编码：使用地址偏移量或者给出四个字节标志的绝对地址指定跳转目标 当执行计算机相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，处理将更新程序计数器作为执行指令的第一步 rep用来实现字符串重复操作，用rep后面跟ret组合来避免使ret指令称为条件跳转指令的目标 处理器使用流水线获得高性能，因此使用条件传送分支会比条件控制转移有更好的性能 处理器采用分支预测逻辑来猜测每条跳转指令是否会执行，发生错误预测时要求处理器丢掉跳转该条指令已经所做的工作，确认分支预测错误的处罚 编译出来使用条件传送的代码所需的时间都是大约8个时钟周期，控制流不依赖于数据，这样可以使处理器更容易保持流水线是满的 循环指令，汇编中使用条件和跳转实现循环 switch根据整数索引值进行多重分支，通过使用跳转表实现的更加高效 过程是一种封装代码的方式，程序用过程作为抽象机制，隐藏程序的具体实现，过程可以是函数、方法、子例程、处理函数等等 过程过程P调用过程Q，Q执行后返回到P，具体实现为以下几个方面 传递控制： 进入程序Q时程序计数器被设置为程序Q的起始位置，返回时程序计数器被设置为P调用Q后面的那条指令的地址 传递数据： P要能够给Q提供一个或多个参数，Q要能够给P返回一个值 分配和释放内存： Q要为局部变量分配空间，返回前必须释放这些空间，Q调用P，Q执行过程中，P以及向上追溯到P的调用链的过程都是被暂时挂起的，当Q运行时只需要为局部变量分配新的存储空间，返回时释放 转移控制 Q调用P，Q执行过程中，P以及向上追溯到P的调用链的过程都是被暂时挂起的，当Q运行时只需要为局部变量分配新的存储空间，返回时释放 程序可以用栈来管理存储空间，栈和程序寄存器存放传递控制和数据、分配内存所需要的信息。P调用Q时，控制和数据信息添加到栈尾，当P返回时这些信息会被释放掉 过程需要的存储空间超过寄存器能够存放的大小时，在栈上分配空间，称为过程的栈帧，正在执行的过程的帧总是在栈顶 P调用Q时，把返回的地址压入栈中 调用可以是直接的也可以是间接的，直接调用时一个标号，间接调用是*后面跟一个操作数指示符 数据传送 大部分进程间的数据传送是通过寄存器实现的 x86-64可以通过寄存器最多传递6个整型参数，寄存器使用的名字取决于传递的数据类型的大小，如果一个函数要传递超过6个整型参数，多余的部分通过栈来传递，参数7位于栈顶 寄存器中的存储空间 栈上的局部存储：寄存器不够存放所有的参数、局部变量使用取地址符&amp;必须返回一个地址、某些局部变量是数组或结构 寄存器是被所有过程共享的资源，但是必须确保当一个过程调用另一个过程时，被调用过程不会覆盖调用者稍后会使用的寄存器值 寄存器%rbx、%rbp、%r12-%r15被划分为被调用者保存寄存器，P调用Q时，Q保存这些寄存器的值 栈指针%rsp 其他寄存器都被划分为调用者保存寄存器 递归过程调用自身，每个调用过程在栈中都有自己的私有空间 栈 缓冲区溢出会导致覆盖栈上存储的某些信息，随着字符串变长，下面的信息会被破坏 如果攻击者可以确定一个web服务器的占空间，可以设计在许多服务器上都能实施的攻击（安全单一化） 栈随机化（地址空间布局随机化Address_Space Layout Randommization ASLR）每次运行时程序的不同部分，都会被加载到内存的不同区域，以此来对抗一些形式的攻击 栈保护者（stacker protector）机制检测缓冲区越界，在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值(canary)，在程序运行时随机产生，在函数返回之前检查金丝雀值是否改变，如果改变程序终止 GCC会试着确定一个函数是否容易受到栈溢出攻击，自动插入溢出检测，使用命令行-fno-stack-protector %fs:40 指明金丝雀值是用段寻址从内存读入的，段寻址机制可以追溯到80826的寻址，将金丝雀值存放在一个特殊的段中，标志为只读，攻击者不能覆盖，函数返回钱对比金丝雀值，两数相同，xorq返回0，函数正常运行，否则代码调用一个错误处理例程 限制可执行代码区域，保存寄存器产生的代码的那部分内存才是可执行的，其他都被限制为只允许读和写，虚拟内存空间在逻辑上被称为页，NX(No-Execute,不执行位)将读和执行模式分开，栈可以被标记为可读和可写 支持变长栈帧：调用alloca函数在栈上分配任意字节数量的存储，x86-64使用%rbp作为帧指针或称为基址针（base pointer）]]></content>
      <categories>
        <category>操作系统基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
